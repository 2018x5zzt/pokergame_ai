# 05 - 礼物互动系统

> AI 斗地主直播项目 · 策划文档
> 版本：v1.0 | 最后更新：2026-02-25

---

## 目录

1. [概述](#1-概述)
2. [抖音礼物数据获取方案](#2-抖音礼物数据获取方案)
3. [礼物到游戏事件映射规则](#3-礼物到游戏事件映射规则)
4. [小礼物效果设计](#4-小礼物效果设计)
5. [中礼物效果设计](#5-中礼物效果设计)
6. [大礼物效果设计](#6-大礼物效果设计)
7. [超级礼物效果设计](#7-超级礼物效果设计)
8. [防滥用机制](#8-防滥用机制)
9. [公平性平衡设计](#9-公平性平衡设计)
10. [礼物效果视觉反馈](#10-礼物效果视觉反馈)
11. [技术实现架构](#11-技术实现架构)
12. [附录](#12-附录)

---

## 1. 概述

### 1.1 设计理念

礼物互动系统是本项目的核心差异化卖点。观众不再是被动观看 AI 打牌，而是通过刷礼物直接影响牌局走向，形成「观众即玩家」的沉浸式互动体验。

### 1.2 核心目标

- **趣味性**：礼物效果有趣、有戏剧性，能引发弹幕讨论
- **公平性**：不能让礼物完全决定胜负，保持竞技观赏性
- **商业性**：合理的礼物分层激励观众消费
- **安全性**：防止恶意刷礼物破坏游戏体验

### 1.3 互动流程总览

```
观众刷礼物 → 抖音服务器 → 礼物监听服务 → 事件队列 → 游戏引擎 → 画面反馈
    ↑                                                              ↓
    └──────────────── 视觉特效 + 音效 + 弹幕感谢 ←─────────────────┘
```

---

## 2. 抖音礼物数据获取方案

### 2.1 方案对比

| 方案 | 原理 | 延迟 | 稳定性 | 接入难度 | 推荐度 |
|------|------|------|--------|---------|--------|
| 抖音开放平台 API | 官方 WebSocket 推送 | 低 (~1s) | 高 | 高（需企业资质） | ★★★ |
| 第三方弹幕姬 | 抓取直播间数据 | 中 (~2s) | 中 | 低 | ★★☆ |
| 浏览器抓包方案 | 拦截浏览器请求 | 中 (~2s) | 低 | 中 | ★☆☆ |
| OBS 弹幕插件 | OBS 插件集成 | 中 | 中 | 低 | ★★☆ |

### 2.2 方案一：抖音开放平台（推荐）

抖音开放平台提供「直播互动」能力，可实时获取礼物、弹幕、点赞等事件。

#### 接入流程

1. 注册抖音开放平台开发者账号（需企业资质）
2. 创建应用，申请「直播互动」权限
3. 通过 OAuth 获取主播授权
4. 建立 WebSocket 长连接，接收实时事件

#### 数据格式示例

```json
{
  "event": "gift",
  "data": {
    "user_id": "123456",
    "nickname": "观众A",
    "gift_id": 1001,
    "gift_name": "小心心",
    "gift_count": 5,
    "gift_value": 1,
    "timestamp": 1708876800000
  }
}
```

#### 核心代码示例

```typescript
import WebSocket from 'ws';

class DouyinGiftListener {
  private ws: WebSocket | null = null;
  private callbacks: Map<string, Function[]> = new Map();

  /** 连接抖音开放平台 WebSocket */
  async connect(roomId: string, accessToken: string): Promise<void> {
    const url = `wss://webcast-open.douyin.com/ws?room_id=${roomId}&access_token=${accessToken}`;
    this.ws = new WebSocket(url);

    this.ws.on('message', (data: Buffer) => {
      const event = JSON.parse(data.toString());
      if (event.event === 'gift') {
        this.emit('gift', event.data);
      }
    });

    this.ws.on('close', () => {
      console.warn('[DouyinGift] 连接断开，5秒后重连...');
      setTimeout(() => this.connect(roomId, accessToken), 5000);
    });
  }

  on(event: string, callback: Function): void {
    if (!this.callbacks.has(event)) this.callbacks.set(event, []);
    this.callbacks.get(event)!.push(callback);
  }

  private emit(event: string, data: any): void {
    this.callbacks.get(event)?.forEach(cb => cb(data));
  }
}
```

### 2.3 方案二：第三方弹幕姬

适用于个人开发者快速接入，无需企业资质。

#### 常用工具

| 工具 | 平台 | 特点 |
|------|------|------|
| 抖音弹幕助手 | Windows | 免费，支持礼物/弹幕/关注事件 |
| DouyinBarrage | 跨平台 | 开源 Python 库，可二次开发 |
| 直播弹幕姬 | Windows | 多平台支持（抖音/B站/快手） |

#### 集成方式

弹幕姬通常提供本地 WebSocket 或 HTTP 接口，游戏引擎通过本地连接获取数据：

```
弹幕姬 → 本地 WebSocket (ws://localhost:8080) → 游戏引擎
```

### 2.4 方案三：浏览器抓包（应急备选）

通过浏览器开发者工具或代理拦截抖音直播间的 WebSocket 数据流，解析礼物事件。

> **风险提示**：此方案依赖抖音前端协议，协议变更会导致失效，仅作为应急备选。

### 2.5 统一礼物事件接口

无论使用哪种获取方案，统一封装为标准事件格式：

```typescript
/** 标准化礼物事件 */
interface GiftEvent {
  /** 事件唯一ID */
  id: string;
  /** 送礼用户ID */
  userId: string;
  /** 送礼用户昵称 */
  nickname: string;
  /** 礼物ID */
  giftId: number;
  /** 礼物名称 */
  giftName: string;
  /** 礼物数量 */
  count: number;
  /** 单个礼物价值（抖币） */
  unitValue: number;
  /** 总价值（抖币） */
  totalValue: number;
  /** 礼物等级: small | medium | large | super */
  tier: 'small' | 'medium' | 'large' | 'super';
  /** 时间戳 */
  timestamp: number;
}
```

---

## 3. 礼物到游戏事件映射规则

### 3.1 礼物分级标准

根据抖音礼物价值（抖币），将礼物分为四个等级：

| 等级 | 价值范围（抖币） | 对应人民币 | 代表礼物 | 效果强度 |
|------|----------------|-----------|---------|---------|
| 小礼物 | 1-9 | ≈0.1-1元 | 小心心、玫瑰、棒棒糖 | 氛围类，不影响牌局 |
| 中礼物 | 10-99 | ≈1-10元 | 墨镜、仙女棒、抖音 | 轻度干预，信息类 |
| 大礼物 | 100-999 | ≈10-100元 | 真爱玫瑰、跑车 | 中度干预，改变牌面 |
| 超级礼物 | 1000+ | ≈100元+ | 嘉年华、城堡、火箭 | 强力干预，改变局势 |

### 3.2 完整礼物-效果对照表

| 礼物名称 | 价值(抖币) | 等级 | 游戏效果 | 效果代码 |
|---------|-----------|------|---------|---------|
| 小心心 | 1 | 小 | 为指定AI加油，显示爱心特效 | `CHEER` |
| 玫瑰 | 1 | 小 | 屏幕飘落玫瑰花瓣 | `ROSE_RAIN` |
| 棒棒糖 | 5 | 小 | 显示加油弹幕气泡 | `BUBBLE_MSG` |
| 墨镜 | 10 | 中 | 偷看指定对手一张随机手牌 | `PEEK_CARD` |
| 仙女棒 | 19 | 中 | 强制指定AI换一张手牌 | `SWAP_CARD` |
| 抖音 | 30 | 中 | 显示指定AI的出牌建议 | `SHOW_HINT` |
| 真爱玫瑰 | 100 | 大 | 指定AI直接获得一张好牌 | `GRANT_CARD` |
| 跑车 | 222 | 大 | 触发当前对局能量加成（虚拟战绩倍数） | `DOUBLE_SCORE` |
| 甜蜜心动 | 500 | 大 | 指定AI下次出牌必出炸弹（如有） | `FORCE_BOMB` |
| 嘉年华 | 1000 | 超级 | 重新洗牌（保留地主身份） | `RESHUFFLE` |
| 城堡 | 2000 | 超级 | 两个农民角色互换手牌 | `SWAP_ROLES` |
| 火箭 | 5000 | 超级 | 触发「观众选地主」特殊模式 | `AUDIENCE_PICK` |

### 3.3 效果触发规则

```typescript
/** 礼物效果映射器 */
class GiftEffectMapper {
  private effectMap: Map<string, GiftEffect> = new Map();

  /** 根据礼物等级和ID映射到游戏效果 */
  mapGiftToEffect(gift: GiftEvent): GameEffect | null {
    // 1. 精确匹配礼物ID
    const exactMatch = this.effectMap.get(String(gift.giftId));
    if (exactMatch) return exactMatch.toGameEffect(gift);

    // 2. 按价值等级匹配默认效果
    switch (gift.tier) {
      case 'small':
        return { type: 'CHEER', target: 'random', data: { nickname: gift.nickname } };
      case 'medium':
        return { type: 'PEEK_CARD', target: 'opponent', data: { count: 1 } };
      case 'large':
        return { type: 'GRANT_CARD', target: 'specified', data: {} };
      case 'super':
        return { type: 'RESHUFFLE', target: 'all', data: {} };
    }
  }
}
```

---

## 4. 小礼物效果设计

### 4.1 设计原则

小礼物（1-9 抖币）是观众参与门槛最低的互动方式，效果定位为**纯氛围类**：

- 不影响任何牌局逻辑
- 视觉效果轻量、不遮挡游戏画面
- 鼓励观众低成本参与，培养互动习惯
- 累计效果可触发特殊彩蛋

### 4.2 效果详细设计

#### CHEER - 加油打气

```yaml
触发礼物:   小心心 (1抖币)
效果描述:   在指定AI头像旁显示爱心特效和加油文字
持续时间:   3秒
目标选择:   观众最近一次弹幕中@的AI名字，默认随机
视觉效果:
  - AI头像周围浮现3-5个爱心气泡
  - 显示 "[昵称] 为 [AI名] 加油！"
音效:       轻快的"叮"声
累计效果:   同一AI累计收到50个加油 → 触发"人气王"特效（金色光环持续30秒）
```

#### ROSE_RAIN - 玫瑰花瓣雨

```yaml
触发礼物:   玫瑰 (1抖币)
效果描述:   屏幕上方飘落玫瑰花瓣
持续时间:   5秒
视觉效果:
  - 10-15片玫瑰花瓣从屏幕顶部随机位置飘落
  - 花瓣有旋转和摇摆动画
  - 透明度渐变，不遮挡游戏画面
音效:       无（避免频繁触发噪音）
累计效果:   10秒内收到10朵以上 → 触发"花瓣暴风雪"（满屏花瓣，持续8秒）
```

#### BUBBLE_MSG - 弹幕气泡

```yaml
触发礼物:   棒棒糖 (5抖币)
效果描述:   在游戏画面边缘显示彩色弹幕气泡
持续时间:   4秒
视觉效果:
  - 圆角矩形气泡，随机彩色背景
  - 显示 "[昵称]: 加油加油！"
  - 气泡从右侧飘入，缓慢向左移动后消失
音效:       气泡"啵"声
累计效果:   无
```

---

## 5. 中礼物效果设计

### 5.1 设计原则

中礼物（10-99 抖币）是互动系统的核心层，效果定位为**信息干预类**：

- 提供信息优势但不直接改变牌面
- 增加观赏趣味性和悬念感
- 效果有冷却时间，防止频繁触发
- 每局每种效果最多触发 3 次

### 5.2 效果详细设计

#### PEEK_CARD - 偷看手牌

```yaml
触发礼物:   墨镜 (10抖币)
效果描述:   随机翻开指定对手的一张手牌，全屏展示3秒
目标选择:   送礼时弹幕指定（如"看地主"），默认看地主
冷却时间:   同一观众 30秒，全局 15秒
每局上限:   每个对手最多被偷看 3 次
视觉效果:
  - 目标AI头像上方出现墨镜图标
  - 一张牌从手牌区飞出，放大展示在屏幕中央
  - 3秒后牌翻转回去，飞回手牌区
  - 底部显示 "[昵称] 偷看了 [AI名] 的手牌！"
音效:       神秘的"嘘~"声 + 翻牌音效
策略影响:   纯信息展示，不改变牌面，但观众可通过弹幕"通风报信"
```

#### SWAP_CARD - 强制换牌

```yaml
触发礼物:   仙女棒 (19抖币)
效果描述:   强制指定AI将一张随机手牌换成牌堆中的随机牌（娱乐效果，不保证有利）
目标选择:   送礼时弹幕指定，默认随机
冷却时间:   同一观众 60秒，全局 30秒
每局上限:   每个AI最多被换牌 2 次
视觉效果:
  - 仙女棒魔法特效覆盖目标AI手牌区
  - 一张牌飞出（旧牌），一张牌飞入（新牌）
  - 新旧牌短暂正面展示对比
  - 显示 "[昵称] 用仙女棒换了 [AI名] 的牌！"
音效:       魔法"叮铃"声
策略影响:   轻度干预，可能换好也可能换差，增加不确定性
```

#### SHOW_HINT - 出牌建议

```yaml
触发礼物:   抖音 (30抖币)
效果描述:   显示指定AI当前最优出牌建议（AI内部决策透明化）
目标选择:   送礼时弹幕指定，默认当前出牌的AI
冷却时间:   同一观众 45秒，全局 20秒
每局上限:   每个AI最多显示 3 次建议
视觉效果:
  - AI头像旁出现思考气泡
  - 气泡中显示推荐出牌组合（高亮手牌）
  - 同时显示AI的"内心独白"（如"这把稳了"/"有点悬"）
  - 5秒后气泡消失
音效:       思考音效（轻柔的"嗯~"）
策略影响:   纯信息展示，让观众了解AI决策逻辑，增加解说趣味
```

---

## 6. 大礼物效果设计

### 6.1 设计原则

大礼物（100-999 抖币）效果定位为**中度干预类**：

- 可以改变牌面，但不能直接决定胜负（合规红线）
- 效果有随机性，不保证一定有利
- 严格的冷却和上限机制
- 触发时有震撼的全屏特效

### 6.2 效果详细设计

#### GRANT_CARD - 获得好牌

```yaml
触发礼物:   真爱玫瑰 (100抖币)
效果描述:   指定AI从牌堆中获得一张高价值牌，替换手中最小的牌
目标选择:   送礼时弹幕指定，默认地主
冷却时间:   同一观众 120秒，全局 60秒
每局上限:   全局最多触发 2 次
规则限制:
  - 获得的牌从剩余牌堆随机抽取（不保证是大牌）
  - 替换掉手中点数最小的一张牌
  - 不能在最后5张牌时触发（防止决定性影响）
视觉效果:
  - 全屏玫瑰花绽放特效（1.5秒）
  - 一张金色光芒的牌从天而降
  - 新牌正面展示2秒，旧牌碎裂消失
  - 显示 "[昵称] 送出真爱玫瑰，[AI名] 获得了 [牌面]！"
音效:       华丽的魔法音效 + 观众欢呼声
```

#### DOUBLE_SCORE - 能量加成

```yaml
触发礼物:   跑车 (222抖币)
效果描述:   当前对局虚拟战绩倍数提升（×2 能量加成）
冷却时间:   每局仅可触发 1 次
每局上限:   1 次
规则限制:
  - 最高能量加成上限为 ×8（防止数值膨胀）
  - 叫地主阶段不可触发（避免与叫分机制冲突）
视觉效果:
  - 跑车从屏幕左侧飞驰而过的全屏动画（2秒）
  - 底分数字放大闪烁，显示 "×2 → ×4"
  - 屏幕边缘金色光效持续5秒
  - 显示 "[昵称] 开着跑车来了！能量加成！"
音效:       跑车引擎轰鸣声 + 金币音效
```

#### FORCE_BOMB - 强制炸弹

```yaml
触发礼物:   甜蜜心动 (500抖币)
效果描述:   指定AI下次出牌时，如果手中有炸弹则必须出炸弹
目标选择:   送礼时弹幕指定
冷却时间:   同一观众 180秒，全局 90秒
每局上限:   全局最多触发 1 次
规则限制:
  - 如果目标AI手中没有炸弹，效果变为"显示该AI没有炸弹"
  - 不强制出火箭（火箭由AI自主决策）
  - 效果在下一次该AI出牌时生效，之后失效
视觉效果:
  - 爱心炸弹特效覆盖目标AI区域
  - 目标AI头像上方出现炸弹倒计时图标
  - 出炸弹时：全屏爆炸特效 + 屏幕震动
  - 没有炸弹时：显示"空欢喜一场~"
音效:       炸弹引线声 → 爆炸声 / 失望音效
```

---

## 7. 超级礼物效果设计

### 7.1 设计原则

超级礼物（1000+ 抖币）是最高等级互动，效果定位为**强力干预类**：

- 效果震撼、有记忆点，是直播高光时刻
- 严格限制触发频率，每局最多 1 次超级效果
- 效果有随机性和戏剧性，不保证绝对有利
- 合规红线：不能直接决定胜负结果（参照 07-合规风控 第四章）
- 全屏级特效，持续时间较长

### 7.2 效果详细设计

#### RESHUFFLE - 重新洗牌

```yaml
触发礼物:   嘉年华 (1000抖币)
效果描述:   保留地主身份不变，三家手牌全部收回重新发牌
冷却时间:   每局仅可触发 1 次，且仅在前10手牌内有效
每局上限:   1 次
规则限制:
  - 地主身份不变，底牌重新随机
  - 已出的牌不回收（仅重新分配未出的牌）
  - 当前倍数保留
  - 如果任一玩家剩余手牌 ≤ 5 张，效果无效（退还礼物价值为游戏积分）
视觉效果:
  - 全屏嘉年华烟花特效（3秒）
  - 所有手牌飞向屏幕中央汇聚成旋涡
  - 旋涡爆散，新牌飞向各玩家
  - 新手牌逐张翻开展示（当前视角玩家）
  - 显示 "[昵称] 触发了嘉年华！命运重新洗牌！"
音效:       烟花爆炸声 + 欢呼声 + 洗牌音效
TTS解说:    "哇！[昵称]送出嘉年华，命运的齿轮重新转动！"
```

#### SWAP_ROLES - 角色互换

```yaml
触发礼物:   城堡 (2000抖币)
效果描述:   两个农民互换全部手牌
冷却时间:   每局仅可触发 1 次
每局上限:   1 次
规则限制:
  - 仅农民之间互换，地主不参与
  - 互换后各自手牌数量保持不变（如果手牌数不同，多出的牌随机丢弃）
  - 叫地主阶段不可触发
视觉效果:
  - 城堡从屏幕底部升起的全屏动画（2秒）
  - 两个农民的手牌同时飞出，在空中交叉
  - 手牌落入对方区域
  - 显示 "[昵称] 建造了城堡！农民们交换了命运！"
音效:       城堡建造音效 + 魔法交换音效
TTS解说:    "[昵称]的城堡改变了战局！两位农民互换了手牌！"
```

#### AUDIENCE_PICK - 观众选地主

```yaml
触发礼物:   火箭 (5000抖币)
效果描述:   下一局进入"观众选地主"特殊模式，由观众投票决定谁当地主
冷却时间:   每 5 局最多触发 1 次
规则限制:
  - 效果在下一局生效（不影响当前局）
  - 进入投票模式后，观众通过弹幕投票（发"1"/"2"/"3"选择对应AI）
  - 投票时间 30 秒（与 06-直播内容与赛事策划 §5.3 保持一致）
  - 得票最多的AI成为地主（平票则随机）
  - 与 06-直播内容与赛事策划 中的"观众选地主"模式保持一致
视觉效果:
  - 火箭发射全屏动画（3秒）
  - 屏幕震动 + 冲击波效果
  - 显示投票倒计时面板
  - 实时显示各AI得票数
  - 显示 "[昵称] 发射了火箭！下一局由观众决定谁当地主！"
音效:       火箭发射音效 + 倒计时音效
TTS解说:    "重磅！[昵称]发射火箭！下一局的地主由你们决定！快投票！"
```

---

## 8. 防滥用机制

### 8.1 冷却时间系统

#### 三级冷却机制

```
个人冷却：同一观众对同一效果的冷却
全局冷却：所有观众对同一效果的冷却
局级限制：每局每种效果的触发上限
```

#### 冷却时间汇总表

| 效果 | 个人冷却 | 全局冷却 | 每局上限 |
|------|---------|---------|---------|
| CHEER | 5秒 | 无 | 无限 |
| ROSE_RAIN | 5秒 | 无 | 无限 |
| BUBBLE_MSG | 10秒 | 无 | 无限 |
| PEEK_CARD | 30秒 | 15秒 | 每人3次 |
| SWAP_CARD | 60秒 | 30秒 | 每人2次 |
| SHOW_HINT | 45秒 | 20秒 | 每人3次 |
| GRANT_CARD | 120秒 | 60秒 | 全局2次 |
| DOUBLE_SCORE | - | - | 全局1次 |
| FORCE_BOMB | 180秒 | 90秒 | 全局1次 |
| RESHUFFLE | - | - | 全局1次 |
| SWAP_ROLES | - | - | 全局1次 |
| AUDIENCE_PICK | - | - | 每5局1次 |

### 8.2 冷却管理器实现

```typescript
class CooldownManager {
  /** 个人冷却记录: Map<`${userId}_${effectType}`, expireTime> */
  private personalCooldowns = new Map<string, number>();
  /** 全局冷却记录: Map<effectType, expireTime> */
  private globalCooldowns = new Map<string, number>();
  /** 局级计数: Map<`${roundId}_${effectType}`, count> */
  private roundCounts = new Map<string, number>();

  canTrigger(userId: string, effectType: string, roundId: string): {
    allowed: boolean;
    reason?: string;
    cooldownRemaining?: number;
  } {
    const now = Date.now();

    // 检查个人冷却
    const personalKey = `${userId}_${effectType}`;
    const personalExpire = this.personalCooldowns.get(personalKey);
    if (personalExpire && now < personalExpire) {
      return {
        allowed: false,
        reason: '个人冷却中',
        cooldownRemaining: Math.ceil((personalExpire - now) / 1000)
      };
    }

    // 检查全局冷却
    const globalExpire = this.globalCooldowns.get(effectType);
    if (globalExpire && now < globalExpire) {
      return {
        allowed: false,
        reason: '全局冷却中',
        cooldownRemaining: Math.ceil((globalExpire - now) / 1000)
      };
    }

    // 检查局级上限
    const roundKey = `${roundId}_${effectType}`;
    const count = this.roundCounts.get(roundKey) || 0;
    const limit = this.getRoundLimit(effectType);
    if (limit > 0 && count >= limit) {
      return { allowed: false, reason: '本局已达上限' };
    }

    return { allowed: true };
  }

  private getRoundLimit(effectType: string): number {
    const limits: Record<string, number> = {
      GRANT_CARD: 2, DOUBLE_SCORE: 1, FORCE_BOMB: 1,
      RESHUFFLE: 1, SWAP_ROLES: 1
    };
    return limits[effectType] ?? -1; // -1 表示无限制
  }
}
```

### 8.3 防刷机制

| 策略 | 说明 |
|------|------|
| 频率限制 | 同一用户每分钟最多触发 5 个效果（不含小礼物） |
| 金额阈值 | 单次礼物连击超过 50 个时，效果只触发一次（避免刷屏） |
| 黑名单 | 恶意刷礼物干扰游戏的用户可被临时屏蔽效果 |
| 效果队列 | 同时触发多个效果时排队执行，避免画面混乱 |
| 阶段锁定 | 叫地主阶段仅允许小礼物效果，出牌阶段开放全部 |

### 8.4 礼物效果无效时的处理

当礼物效果因冷却/上限/阶段限制无法触发时：

```yaml
处理方式:
  1. 仍然显示礼物动画（抖音原生特效）
  2. 显示提示: "效果冷却中，[X]秒后可再次触发"
  3. 礼物价值计入观众贡献榜（不浪费）
  4. 不退还礼物（这是抖音平台行为，我们无法控制）
```

---

## 9. 公平性平衡设计

### 9.1 设计哲学

礼物互动的核心矛盾：**商业激励**要求礼物效果足够强力以刺激消费，**竞技公平**要求礼物不能决定胜负。我们的平衡策略是：

```
礼物效果 = 娱乐性 × 随机性 × 限制性
```

- **娱乐性**：效果有趣、有戏剧性，观众愿意为"看热闹"付费
- **随机性**：效果结果不确定，刷礼物不等于"买赢"
- **限制性**：严格的频率和上限控制，防止礼物主导比赛

### 9.2 公平性量化指标

#### 礼物影响力评估模型

```typescript
/** 礼物对胜率的影响评估 */
interface FairnessMetrics {
  /** 效果对目标AI胜率的预期变化（百分点） */
  winRateDelta: number;
  /** 效果的随机性系数（0=完全确定, 1=完全随机） */
  randomnessFactor: number;
  /** 每局最大累计影响（百分点） */
  maxCumulativeImpact: number;
}

const FAIRNESS_LIMITS: Record<string, FairnessMetrics> = {
  // 小礼物：零影响
  CHEER:        { winRateDelta: 0,   randomnessFactor: 1.0, maxCumulativeImpact: 0 },
  ROSE_RAIN:    { winRateDelta: 0,   randomnessFactor: 1.0, maxCumulativeImpact: 0 },
  BUBBLE_MSG:   { winRateDelta: 0,   randomnessFactor: 1.0, maxCumulativeImpact: 0 },

  // 中礼物：信息类，间接影响 ≤ 3%
  PEEK_CARD:    { winRateDelta: 1.5, randomnessFactor: 0.7, maxCumulativeImpact: 3 },
  SWAP_CARD:    { winRateDelta: 0.5, randomnessFactor: 0.9, maxCumulativeImpact: 2 },
  SHOW_HINT:    { winRateDelta: 0,   randomnessFactor: 1.0, maxCumulativeImpact: 0 },

  // 大礼物：中度干预，单次影响 ≤ 5%
  GRANT_CARD:   { winRateDelta: 3.0, randomnessFactor: 0.6, maxCumulativeImpact: 5 },
  DOUBLE_SCORE: { winRateDelta: 0,   randomnessFactor: 1.0, maxCumulativeImpact: 0 },
  FORCE_BOMB:   { winRateDelta: 2.0, randomnessFactor: 0.5, maxCumulativeImpact: 2 },

  // 超级礼物：强力干预，但高随机性
  RESHUFFLE:    { winRateDelta: 0,   randomnessFactor: 1.0, maxCumulativeImpact: 0 },
  SWAP_ROLES:   { winRateDelta: 0,   randomnessFactor: 1.0, maxCumulativeImpact: 0 },
  AUDIENCE_PICK:{ winRateDelta: 0,   randomnessFactor: 1.0, maxCumulativeImpact: 0 },
};
```

#### 公平性红线

| 指标 | 红线值 | 说明 |
|------|--------|------|
| 单次效果胜率影响 | ≤ 5% | 任何单次礼物效果不得使目标AI胜率变化超过5个百分点 |
| 每局累计影响 | ≤ 10% | 一局中所有礼物效果的累计胜率影响不超过10个百分点 |
| 效果确定性 | ≤ 0.5 | 效果结果的确定性系数不超过0.5（即至少50%随机性） |
| 连续受益上限 | 3局 | 同一AI不得连续3局以上成为礼物效果的主要受益者 |

### 9.3 平衡机制详细设计

#### 9.3.1 随机性保障

所有改变牌面的效果都包含随机因素：

```typescript
class FairnessGuard {
  /**
   * GRANT_CARD 的公平性处理
   * 不是直接给"好牌"，而是从剩余牌堆随机抽取
   */
  processGrantCard(targetPlayer: Player, remainingDeck: Card[]): {
    newCard: Card;
    removedCard: Card;
  } {
    // 随机抽取，不保证是大牌
    const randomIndex = Math.floor(Math.random() * remainingDeck.length);
    const newCard = remainingDeck[randomIndex];

    // 移除手中最小的牌
    const sortedHand = [...targetPlayer.hand].sort((a, b) => a.value - b.value);
    const removedCard = sortedHand[0];

    return { newCard, removedCard };
  }

  /**
   * SWAP_CARD 的公平性处理
   * 换牌结果完全随机，可能换好也可能换差
   */
  processSwapCard(targetPlayer: Player, remainingDeck: Card[]): {
    oldCard: Card;
    newCard: Card;
    isUpgrade: boolean;
  } {
    // 随机选择要换出的牌
    const handIndex = Math.floor(Math.random() * targetPlayer.hand.length);
    const oldCard = targetPlayer.hand[handIndex];

    // 随机选择要换入的牌
    const deckIndex = Math.floor(Math.random() * remainingDeck.length);
    const newCard = remainingDeck[deckIndex];

    return {
      oldCard,
      newCard,
      isUpgrade: newCard.value > oldCard.value
    };
  }

  /**
   * RESHUFFLE 的公平性处理
   * 完全重新洗牌，对所有玩家影响相同
   */
  processReshuffle(players: Player[]): Card[][] {
    // 收集所有未出的牌
    const allCards = players.flatMap(p => p.hand);

    // Fisher-Yates 洗牌算法
    for (let i = allCards.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [allCards[i], allCards[j]] = [allCards[j], allCards[i]];
    }

    // 按原手牌数量重新分配
    const newHands: Card[][] = [];
    let offset = 0;
    for (const player of players) {
      const count = player.hand.length;
      newHands.push(allCards.slice(offset, offset + count));
      offset += count;
    }

    return newHands;
  }
}
```

#### 9.3.2 受益者轮转机制

防止同一AI持续成为礼物效果的受益者：

```typescript
class BenefitTracker {
  /** 记录每个AI最近N局的受益次数 */
  private benefitHistory: Map<string, number[]> = new Map();
  private windowSize = 5; // 滑动窗口：最近5局

  /** 记录一次受益事件 */
  recordBenefit(aiId: string, roundId: number): void {
    if (!this.benefitHistory.has(aiId)) {
      this.benefitHistory.set(aiId, []);
    }
    const history = this.benefitHistory.get(aiId)!;
    history.push(roundId);

    // 保持窗口大小
    while (history.length > this.windowSize) {
      history.shift();
    }
  }

  /** 检查是否允许该AI继续受益 */
  canBenefit(aiId: string): { allowed: boolean; reason?: string } {
    const history = this.benefitHistory.get(aiId) || [];
    const recentCount = history.length;

    // 连续3局以上受益则限制
    if (recentCount >= 3) {
      return {
        allowed: false,
        reason: `${aiId} 近期受益过多，效果将随机分配给其他AI`
      };
    }
    return { allowed: true };
  }

  /** 获取推荐的受益目标（优先选择近期受益最少的AI） */
  getRecommendedTarget(aiIds: string[]): string {
    let minBenefits = Infinity;
    let recommended = aiIds[0];

    for (const id of aiIds) {
      const count = (this.benefitHistory.get(id) || []).length;
      if (count < minBenefits) {
        minBenefits = count;
        recommended = id;
      }
    }
    return recommended;
  }
}
```

#### 9.3.3 阶段性效果锁定

不同游戏阶段允许的效果类型不同：

| 游戏阶段 | 允许的效果等级 | 说明 |
|---------|-------------|------|
| 发牌阶段 | 无 | 发牌过程不接受任何效果 |
| 叫地主阶段 | 仅小礼物 | 叫分决策不受干扰 |
| 出牌阶段（前5手） | 全部 | 开放所有效果 |
| 出牌阶段（后5张牌） | 小礼物 + 中礼物 | 禁止大/超级效果，防止决定性影响 |
| 结算阶段 | 仅小礼物 | 结果已定，仅允许氛围效果 |

### 9.4 合规性对齐

> 本节设计严格遵循 `07-合规风控` 第四章「礼物互动合规」的要求。

| 合规要求 | 本系统实现 |
|---------|-----------|
| 礼物效果不得直接决定胜负 | 所有效果含随机性，winRateDelta ≤ 5% |
| 不得出现"充值即赢"暗示 | 效果描述使用"娱乐""趣味"等中性词汇 |
| 虚拟积分不可兑换现金 | 积分仅用于排行榜展示，无提现功能 |
| 未成年人保护 | 遵循抖音平台未成年人消费限制 |
| AI 内容标识 | 所有礼物效果画面包含 AI 生成标识 |

### 9.5 数据监控与动态调整

```typescript
/** 公平性监控仪表盘数据 */
interface FairnessDashboard {
  /** 各AI近10局胜率（含礼物影响） */
  winRatesWithGifts: Record<string, number>;
  /** 各AI近10局胜率（排除礼物影响的模拟值） */
  winRatesWithoutGifts: Record<string, number>;
  /** 礼物影响偏差（两者差值） */
  giftBias: Record<string, number>;
  /** 各效果触发次数统计 */
  effectTriggerCounts: Record<string, number>;
  /** 观众满意度指标（基于弹幕情感分析） */
  audienceSentiment: number;
}

// 当礼物偏差超过阈值时自动调整
function autoBalanceCheck(dashboard: FairnessDashboard): void {
  for (const [aiId, bias] of Object.entries(dashboard.giftBias)) {
    if (Math.abs(bias) > 10) {
      console.warn(`[公平性警告] ${aiId} 的礼物偏差为 ${bias}%，触发自动平衡`);
      // 临时提高该AI被负面效果影响的概率 / 降低被正面效果影响的概率
    }
  }
}
```

---

## 10. 礼物效果视觉反馈

### 10.1 视觉反馈分层架构

礼物效果的视觉反馈分为三个渲染层，从下到上叠加：

```
┌─────────────────────────────────────┐
│  Layer 3: 全屏特效层 (超级礼物)      │  z-index: 300
│  - 嘉年华烟花、火箭发射等全屏动画    │
├─────────────────────────────────────┤
│  Layer 2: 局部特效层 (中/大礼物)      │  z-index: 200
│  - 偷看手牌、换牌动画、炸弹特效      │
├─────────────────────────────────────┤
│  Layer 1: 氛围特效层 (小礼物)         │  z-index: 100
│  - 爱心气泡、花瓣雨、弹幕气泡        │
├─────────────────────────────────────┤
│  Layer 0: 游戏主画面                  │  z-index: 0
│  - 牌桌、手牌、出牌区域              │
└─────────────────────────────────────┘
```

### 10.2 特效渲染技术选型

| 技术 | 适用场景 | 性能 | 推荐度 |
|------|---------|------|--------|
| CSS Animation | 简单位移/透明度动画 | 极高 | ★★★ |
| Canvas 2D | 粒子效果（花瓣、爱心） | 高 | ★★★ |
| Lottie (lottie-web) | 复杂矢量动画（预制） | 高 | ★★☆ |
| PIXI.js | 高性能粒子系统 | 中高 | ★★☆ |
| CSS + FLIP 动画 | 牌面移动/翻转 | 高 | ★★★ |

推荐组合：**CSS Animation + Canvas 2D 粒子 + Lottie 预制动画**

### 10.3 特效管理器实现

```typescript
/** 特效优先级与并发控制 */
interface EffectConfig {
  /** 特效类型 */
  type: string;
  /** 渲染层级 */
  layer: 1 | 2 | 3;
  /** 持续时间(ms) */
  duration: number;
  /** 优先级（数值越大越优先） */
  priority: number;
  /** 是否独占层级（播放时阻止同层其他特效） */
  exclusive: boolean;
}

class EffectManager {
  private activeEffects: Map<number, string[]> = new Map(); // layer → active effect ids
  private effectQueue: Array<{ config: EffectConfig; data: any }> = [];
  private maxConcurrentPerLayer = 3;

  /** 请求播放特效 */
  async playEffect(config: EffectConfig, data: any): Promise<void> {
    const layerEffects = this.activeEffects.get(config.layer) || [];

    // 独占层级检查
    if (config.exclusive && layerEffects.length > 0) {
      this.effectQueue.push({ config, data });
      return;
    }

    // 并发上限检查
    if (layerEffects.length >= this.maxConcurrentPerLayer) {
      this.effectQueue.push({ config, data });
      return;
    }

    await this.executeEffect(config, data);
  }

  private async executeEffect(config: EffectConfig, data: any): Promise<void> {
    const effectId = `${config.type}_${Date.now()}`;
    const layerEffects = this.activeEffects.get(config.layer) || [];
    layerEffects.push(effectId);
    this.activeEffects.set(config.layer, layerEffects);

    // 触发渲染
    this.renderEffect(config, data);

    // 定时清理
    setTimeout(() => {
      this.removeEffect(config.layer, effectId);
      this.processQueue();
    }, config.duration);
  }

  private renderEffect(config: EffectConfig, data: any): void {
    // 根据 config.type 分发到具体渲染器
    switch (config.type) {
      case 'CHEER':
      case 'ROSE_RAIN':
      case 'BUBBLE_MSG':
        this.renderParticleEffect(config, data);
        break;
      case 'PEEK_CARD':
      case 'SWAP_CARD':
      case 'GRANT_CARD':
        this.renderCardAnimation(config, data);
        break;
      case 'RESHUFFLE':
      case 'AUDIENCE_PICK':
        this.renderFullscreenAnimation(config, data);
        break;
      default:
        this.renderLottieAnimation(config, data);
    }
  }

  private renderParticleEffect(config: EffectConfig, data: any): void { /* Canvas 2D 粒子 */ }
  private renderCardAnimation(config: EffectConfig, data: any): void { /* CSS FLIP 动画 */ }
  private renderFullscreenAnimation(config: EffectConfig, data: any): void { /* Lottie 全屏 */ }
  private renderLottieAnimation(config: EffectConfig, data: any): void { /* Lottie 通用 */ }

  private removeEffect(layer: number, effectId: string): void {
    const effects = this.activeEffects.get(layer) || [];
    this.activeEffects.set(layer, effects.filter(id => id !== effectId));
  }

  private processQueue(): void {
    if (this.effectQueue.length === 0) return;
    // 按优先级排序后尝试播放
    this.effectQueue.sort((a, b) => b.config.priority - a.config.priority);
    const next = this.effectQueue.shift()!;
    this.playEffect(next.config, next.data);
  }
}
```

### 10.4 各效果视觉规格汇总

| 效果 | 渲染层 | 持续时间 | 独占 | 优先级 | 渲染技术 |
|------|--------|---------|------|--------|---------|
| CHEER | Layer 1 | 3s | 否 | 10 | CSS Animation |
| ROSE_RAIN | Layer 1 | 5s | 否 | 10 | Canvas 2D 粒子 |
| BUBBLE_MSG | Layer 1 | 4s | 否 | 10 | CSS Animation |
| PEEK_CARD | Layer 2 | 5s | 是 | 50 | CSS FLIP + 缩放 |
| SWAP_CARD | Layer 2 | 4s | 是 | 50 | CSS FLIP + 位移 |
| SHOW_HINT | Layer 2 | 5s | 否 | 40 | CSS Animation |
| GRANT_CARD | Layer 2 | 4s | 是 | 60 | Lottie + CSS |
| DOUBLE_SCORE | Layer 2 | 3s | 是 | 70 | Lottie 预制 |
| FORCE_BOMB | Layer 2 | 5s | 是 | 80 | Lottie + 屏幕震动 |
| RESHUFFLE | Layer 3 | 6s | 是 | 100 | Lottie 全屏 |
| SWAP_ROLES | Layer 3 | 5s | 是 | 100 | Lottie 全屏 |
| AUDIENCE_PICK | Layer 3 | 18s | 是 | 100 | React 组件 + CSS |

### 10.5 音效资源规划

| 效果 | 音效文件 | 时长 | 音量 |
|------|---------|------|------|
| CHEER | `sfx/cheer_ding.mp3` | 0.5s | 60% |
| ROSE_RAIN | 无 | - | - |
| BUBBLE_MSG | `sfx/bubble_pop.mp3` | 0.3s | 50% |
| PEEK_CARD | `sfx/peek_shh.mp3` + `sfx/card_flip.mp3` | 1.5s | 70% |
| SWAP_CARD | `sfx/magic_wand.mp3` | 1.0s | 70% |
| SHOW_HINT | `sfx/thinking_hmm.mp3` | 1.0s | 60% |
| GRANT_CARD | `sfx/magic_bloom.mp3` + `sfx/crowd_cheer.mp3` | 2.0s | 80% |
| DOUBLE_SCORE | `sfx/car_engine.mp3` + `sfx/coin_drop.mp3` | 2.5s | 85% |
| FORCE_BOMB | `sfx/bomb_fuse.mp3` + `sfx/explosion.mp3` | 3.0s | 90% |
| RESHUFFLE | `sfx/fireworks.mp3` + `sfx/shuffle.mp3` | 4.0s | 90% |
| SWAP_ROLES | `sfx/castle_build.mp3` + `sfx/magic_swap.mp3` | 3.0s | 85% |
| AUDIENCE_PICK | `sfx/rocket_launch.mp3` + `sfx/countdown.mp3` | 5.0s | 95% |

### 10.6 性能优化策略

| 策略 | 说明 |
|------|------|
| 特效预加载 | 开播时预加载所有 Lottie JSON 和音效文件到内存 |
| 对象池复用 | 粒子对象使用对象池，避免频繁 GC |
| 离屏 Canvas | 粒子效果使用 OffscreenCanvas（Web Worker 渲染） |
| 帧率自适应 | 检测设备性能，低端设备降低粒子数量 |
| 特效降级 | OBS 编码器负载 > 90% 时，自动简化特效（减少粒子、缩短时长） |

---

## 11. 技术实现架构

### 11.1 整体架构图

```
┌──────────────┐     WebSocket      ┌──────────────────┐
│  抖音直播间   │ ─────────────────→ │  礼物监听服务     │
│  (礼物事件)   │                    │  GiftListener     │
└──────────────┘                    └────────┬─────────┘
                                             │ 标准化 GiftEvent
                                             ▼
                                    ┌──────────────────┐
                                    │  事件处理管道     │
                                    │  EventPipeline    │
                                    │                  │
                                    │  ┌─ 去重过滤 ──┐ │
                                    │  ├─ 冷却检查 ──┤ │
                                    │  ├─ 公平性检查 ─┤ │
                                    │  ├─ 阶段锁定 ──┤ │
                                    │  └─ 效果映射 ──┘ │
                                    └────────┬─────────┘
                                             │ GameEffect
                                    ┌────────┴─────────┐
                              ┌─────┴─────┐     ┌──────┴──────┐
                              │ 游戏引擎   │     │ 特效引擎    │
                              │ 执行效果   │     │ 渲染动画    │
                              └───────────┘     └─────────────┘
```

### 11.2 事件处理管道

```typescript
/** 管道式事件处理器 */
class EventPipeline {
  private filters: EventFilter[] = [];

  /** 注册过滤器（按顺序执行） */
  use(filter: EventFilter): this {
    this.filters.push(filter);
    return this;
  }

  /** 处理礼物事件，通过所有过滤器后输出游戏效果 */
  async process(gift: GiftEvent): Promise<GameEffect | null> {
    let context: PipelineContext = {
      gift,
      effect: null,
      rejected: false,
      rejectReason: ''
    };

    for (const filter of this.filters) {
      context = await filter.handle(context);
      if (context.rejected) {
        console.log(`[Pipeline] 事件被拒绝: ${context.rejectReason}`);
        return null;
      }
    }

    return context.effect;
  }
}

interface EventFilter {
  handle(ctx: PipelineContext): Promise<PipelineContext>;
}

interface PipelineContext {
  gift: GiftEvent;
  effect: GameEffect | null;
  rejected: boolean;
  rejectReason: string;
}
```

### 11.3 各过滤器实现

#### 去重过滤器

```typescript
/** 防止同一礼物事件被重复处理 */
class DeduplicationFilter implements EventFilter {
  private processedIds = new Set<string>();
  private maxSize = 10000;

  async handle(ctx: PipelineContext): Promise<PipelineContext> {
    if (this.processedIds.has(ctx.gift.id)) {
      ctx.rejected = true;
      ctx.rejectReason = '重复事件';
      return ctx;
    }
    this.processedIds.add(ctx.gift.id);

    // 防止内存泄漏
    if (this.processedIds.size > this.maxSize) {
      const entries = [...this.processedIds];
      this.processedIds = new Set(entries.slice(-this.maxSize / 2));
    }
    return ctx;
  }
}
```

#### 阶段锁定过滤器

```typescript
/** 根据游戏阶段限制可触发的效果等级 */
class PhaseFilter implements EventFilter {
  constructor(private gameState: GameStateProvider) {}

  async handle(ctx: PipelineContext): Promise<PipelineContext> {
    const phase = this.gameState.getCurrentPhase();
    const tier = ctx.gift.tier;

    const allowed = this.isAllowed(phase, tier);
    if (!allowed) {
      ctx.rejected = true;
      ctx.rejectReason = `当前阶段(${phase})不允许${tier}级别效果`;
    }
    return ctx;
  }

  private isAllowed(phase: string, tier: string): boolean {
    const rules: Record<string, string[]> = {
      'DEALING':    [],
      'BIDDING':    ['small'],
      'PLAYING':    ['small', 'medium', 'large', 'super'],
      'ENDGAME':    ['small', 'medium'],  // 剩余≤5张牌
      'SETTLEMENT': ['small']
    };
    return (rules[phase] || []).includes(tier);
  }
}
```

### 11.4 管道组装与初始化

```typescript
/** 礼物互动系统初始化 */
function initGiftSystem(
  gameState: GameStateProvider,
  giftListener: DouyinGiftListener
): void {
  const cooldownManager = new CooldownManager();
  const benefitTracker = new BenefitTracker();
  const effectMapper = new GiftEffectMapper();
  const effectManager = new EffectManager();

  // 组装事件处理管道
  const pipeline = new EventPipeline()
    .use(new DeduplicationFilter())
    .use(new PhaseFilter(gameState))
    .use(new CooldownFilter(cooldownManager))
    .use(new FairnessFilter(benefitTracker))
    .use(new EffectMappingFilter(effectMapper));

  // 监听礼物事件
  giftListener.on('gift', async (rawGift: any) => {
    // 标准化
    const gift = normalizeGiftEvent(rawGift);

    // 通过管道处理
    const effect = await pipeline.process(gift);
    if (!effect) return;

    // 执行游戏效果
    gameState.applyEffect(effect);

    // 播放视觉特效
    await effectManager.playEffect(
      EFFECT_CONFIGS[effect.type],
      { ...effect.data, nickname: gift.nickname }
    );

    // 记录日志
    logGiftEffect(gift, effect);
  });
}
```

### 11.5 数据持久化与统计

```typescript
/** 礼物效果日志记录 */
interface GiftEffectLog {
  /** 礼物事件ID */
  giftEventId: string;
  /** 送礼用户 */
  userId: string;
  nickname: string;
  /** 礼物信息 */
  giftName: string;
  giftValue: number;
  /** 触发的效果 */
  effectType: string;
  /** 效果是否成功执行 */
  executed: boolean;
  /** 拒绝原因（如有） */
  rejectReason?: string;
  /** 对局ID */
  roundId: string;
  /** 时间戳 */
  timestamp: number;
}

/** 统计数据接口 */
interface GiftStatistics {
  /** 本场直播礼物总价值（抖币） */
  totalGiftValue: number;
  /** 各等级礼物数量 */
  tierCounts: Record<string, number>;
  /** 各效果触发次数 */
  effectCounts: Record<string, number>;
  /** 效果被拒绝次数（按原因分类） */
  rejectionCounts: Record<string, number>;
  /** 观众贡献排行榜 Top 10 */
  topContributors: Array<{
    userId: string;
    nickname: string;
    totalValue: number;
  }>;
}
```

---

## 12. 附录

### 12.1 抖音常见礼物 ID 映射表

> 以下为抖音平台常见礼物的参考 ID，实际 ID 可能随平台更新变化，需通过抖音开放平台 API 动态获取。

| 礼物名称 | 参考 gift_id | 价值(抖币) | 本系统等级 | 映射效果 |
|---------|-------------|-----------|-----------|---------|
| 小心心 | 1 | 1 | small | CHEER |
| 玫瑰 | 2 | 1 | small | ROSE_RAIN |
| 棒棒糖 | 3 | 5 | small | BUBBLE_MSG |
| 墨镜 | 10 | 10 | medium | PEEK_CARD |
| 仙女棒 | 11 | 19 | medium | SWAP_CARD |
| 抖音 | 12 | 30 | medium | SHOW_HINT |
| 真爱玫瑰 | 20 | 100 | large | GRANT_CARD |
| 跑车 | 21 | 222 | large | DOUBLE_SCORE |
| 甜蜜心动 | 22 | 500 | large | FORCE_BOMB |
| 嘉年华 | 30 | 1000 | super | RESHUFFLE |
| 城堡 | 31 | 2000 | super | SWAP_ROLES |
| 火箭 | 32 | 5000 | super | AUDIENCE_PICK |

> **注意**：未在映射表中的礼物，按价值自动归入对应等级，触发该等级的默认效果。

### 12.2 效果代码速查表

| 效果代码 | 中文名 | 等级 | 影响牌局 | 冷却(个人/全局) |
|---------|--------|------|---------|----------------|
| `CHEER` | 加油打气 | 小 | ✗ | 5s / 无 |
| `ROSE_RAIN` | 玫瑰花瓣雨 | 小 | ✗ | 5s / 无 |
| `BUBBLE_MSG` | 弹幕气泡 | 小 | ✗ | 10s / 无 |
| `PEEK_CARD` | 偷看手牌 | 中 | △ 信息 | 30s / 15s |
| `SWAP_CARD` | 强制换牌 | 中 | △ 随机 | 60s / 30s |
| `SHOW_HINT` | 出牌建议 | 中 | ✗ | 45s / 20s |
| `GRANT_CARD` | 获得好牌 | 大 | ○ 随机 | 120s / 60s |
| `DOUBLE_SCORE` | 能量加成 | 大 | △ 积分 | 每局1次 |
| `FORCE_BOMB` | 强制炸弹 | 大 | ○ 条件 | 180s / 90s |
| `RESHUFFLE` | 重新洗牌 | 超级 | ● 全局 | 每局1次 |
| `SWAP_ROLES` | 角色互换 | 超级 | ● 全局 | 每局1次 |
| `AUDIENCE_PICK` | 观众选地主 | 超级 | ● 下局 | 每5局1次 |

> 图例：✗ 不影响 | △ 轻度 | ○ 中度 | ● 强力

### 12.3 依赖库清单

| 库名 | 版本 | 用途 | 安装命令 |
|------|------|------|---------|
| ws | 8.x | WebSocket 客户端（连接抖音） | `npm i ws` |
| lottie-web | 5.x | Lottie 动画渲染 | `npm i lottie-web` |
| howler.js | 2.x | 音效播放管理 | `npm i howler` |
| uuid | 9.x | 生成唯一事件ID | `npm i uuid` |
| eventemitter3 | 5.x | 高性能事件发射器 | `npm i eventemitter3` |

### 12.4 跨文档引用索引

| 引用文档 | 引用章节 | 本文档关联内容 |
|---------|---------|--------------|
| 01-斗地主规则 | 全文 | 礼物效果需遵循的游戏规则基础 |
| 03-特效与动画设计 | §3 粒子系统、§4 动画规范 | 礼物特效的渲染技术与动画标准 |
| 06-直播内容与赛事策划 | §5.3 观众选地主模式 | AUDIENCE_PICK 投票时间30秒对齐 |
| 07-抖音合规与风控 | §4 礼物互动合规 | 公平性红线、措辞合规、AI标识 |
| 08-技术架构设计 | §3 模块通信 | 礼物系统与游戏引擎的集成接口 |
| 09-运营与商业化 | §4 礼物收入分析 | 礼物分级与商业化策略对齐 |

### 12.5 常见问题排查

| 问题 | 可能原因 | 解决方案 |
|------|---------|---------|
| 礼物事件收不到 | WebSocket 连接断开 | 检查 GiftListener 重连逻辑 |
| 效果延迟过高 (>3s) | 事件队列积压 | 增加管道并发处理能力 |
| 特效不显示 | Lottie JSON 加载失败 | 检查资源预加载，确认路径正确 |
| 音效不播放 | 浏览器自动播放策略 | 需用户首次交互后解锁音频上下文 |
| 冷却时间不准确 | 服务器时间不同步 | 使用 NTP 同步，或基于单调时钟 |
| 同一效果重复触发 | 去重过滤器未生效 | 检查 gift.id 是否唯一 |
| 公平性偏差过大 | BenefitTracker 窗口过小 | 调大 windowSize 或降低阈值 |

---

> 文档结束 | AI 斗地主直播项目 · 礼物互动系统 v1.0
