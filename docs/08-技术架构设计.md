# 08 - 技术架构设计

> AI 斗地主直播项目 · 技术文档
> 版本：v1.0 | 最后更新：2026-02-25

---

## 目录

1. [系统架构总览](#1-系统架构总览)
2. [游戏引擎模块](#2-游戏引擎模块)
3. [AI 决策模块（CCCC 集成）](#3-ai-决策模块cccc-集成)
4. [前端渲染模块](#4-前端渲染模块)
5. [直播推流模块](#5-直播推流模块)
6. [礼物监听与互动模块](#6-礼物监听与互动模块)
7. [数据存储方案](#7-数据存储方案)
8. [模块间通信协议](#8-模块间通信协议)
9. [部署方案](#9-部署方案)
10. [技术选型对比与决策](#10-技术选型对比与决策)
11. [性能与可靠性设计](#11-性能与可靠性设计)
12. [附录](#12-附录)

---

## 1. 系统架构总览

### 1.1 架构设计原则

| 原则 | 说明 |
|------|------|
| 模块化 | 各功能模块独立开发、独立部署、松耦合 |
| 事件驱动 | 模块间通过事件总线通信，异步非阻塞 |
| 可观测性 | 关键链路埋点监控，实时掌握系统健康状态 |
| 容错性 | 单模块故障不影响整体直播，自动降级 |
| 本地优先 | 核心逻辑本地运行，减少外部依赖和网络延迟 |

### 1.2 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        抖音直播平台                               │
│   ┌──────────┐    ┌──────────┐    ┌──────────┐                 │
│   │ 直播画面  │    │ 弹幕流   │    │ 礼物事件  │                 │
│   └─────┬────┘    └─────┬────┘    └─────┬────┘                 │
└─────────┼───────────────┼───────────────┼──────────────────────┘
     RTMP推流          WebSocket        WebSocket
          │               │               │
┌─────────┴───────────────┴───────────────┴──────────────────────┐
│                       本地服务层                                 │
│                                                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐    │
│  │  OBS 推流    │  │  弹幕监听    │  │  礼物监听服务        │    │
│  │  Controller  │  │  Service     │  │  GiftListener       │    │
│  └──────┬──────┘  └──────┬──────┘  └──────────┬──────────┘    │
│         │                │                     │               │
│  ┌──────┴────────────────┴─────────────────────┴──────────┐   │
│  │                    事件总线 (EventBus)                    │   │
│  └──┬──────────┬──────────┬──────────┬──────────┬─────────┘   │
│     │          │          │          │          │              │
│  ┌──┴───┐  ┌──┴───┐  ┌──┴───┐  ┌──┴───┐  ┌──┴───┐         │
│  │ 游戏  │  │ AI   │  │ 前端  │  │ 礼物  │  │ 数据  │         │
│  │ 引擎  │  │ 决策  │  │ 渲染  │  │ 效果  │  │ 存储  │         │
│  │Engine │  │CCCC  │  │React │  │Effect│  │Store │         │
│  └──────┘  └──────┘  └──────┘  └──────┘  └──────┘         │
└─────────────────────────────────────────────────────────────────┘
```

### 1.3 技术栈总览

| 层级 | 技术选型 | 说明 |
|------|---------|------|
| 游戏引擎 | TypeScript | 斗地主规则、牌型判断、游戏流程控制 |
| AI 决策 | CCCC 多智能体框架 | 三个 AI 智能体独立决策 |
| 前端渲染 | React 18 + PixiJS 7 (WebGL 2D) + GSAP 3 | 游戏画面渲染、特效动画 |
| 状态管理 | Zustand 4+ | 前端全局状态管理 |
| 推流控制 | OBS Studio + obs-websocket-js | 画面捕获、场景切换、推流管理 |
| 礼物监听 | WebSocket (ws) | 连接抖音开放平台或弹幕姬 |
| 数据存储 | SQLite + JSON 文件 | 对局记录、统计数据、配置 |
| TTS 解说 | Edge TTS (edge-tts) | AI 语音解说 |
| 构建工具 | Vite + TypeScript | 前端构建、热更新 |
| 包管理 | pnpm | 依赖管理 |
| 运行时 | Node.js 18+ | 服务端运行环境 |

### 1.4 目录结构设计

```
zhibo_doudizhu/
├── docs/                          # 策划文档（当前目录）
├── packages/                      # Monorepo 多包结构
│   ├── engine/                    # 游戏引擎
│   │   ├── src/
│   │   │   ├── core/              # 核心规则（牌型、比较、发牌）
│   │   │   ├── game/              # 游戏流程（叫地主、出牌、结算）
│   │   │   ├── types/             # TypeScript 类型定义
│   │   │   └── index.ts
│   │   ├── tests/
│   │   └── package.json
│   ├── ai/                        # AI 决策模块
│   │   ├── src/
│   │   │   ├── agents/            # AI 智能体（地主、农民）
│   │   │   ├── strategies/        # 出牌策略
│   │   │   ├── cccc/              # CCCC 框架集成
│   │   │   └── index.ts
│   │   └── package.json
│   ├── frontend/                  # 前端渲染
│   │   ├── src/
│   │   │   ├── components/        # React 组件
│   │   │   ├── renderer/           # PixiJS 渲染器
│   │   │   ├── effects/           # 特效系统
│   │   │   ├── overlay/           # OBS 覆盖层
│   │   │   └── App.tsx
│   │   └── package.json
│   ├── server/                    # 服务端
│   │   ├── src/
│   │   │   ├── gift/              # 礼物监听与处理
│   │   │   ├── obs/               # OBS 控制
│   │   │   ├── tts/               # TTS 解说
│   │   │   ├── storage/           # 数据存储
│   │   │   ├── eventbus/          # 事件总线
│   │   │   └── index.ts
│   │   └── package.json
│   └── shared/                    # 共享类型与工具
│       ├── src/
│       │   ├── types/             # 跨模块共享类型
│       │   ├── constants/         # 常量定义
│       │   └── utils/             # 工具函数
│       └── package.json
├── assets/                        # 静态资源
│   ├── cards/                     # 扑克牌图片
│   ├── avatars/                   # AI 头像
│   ├── sfx/                       # 音效文件
│   ├── bgm/                       # 背景音乐
│   └── lottie/                    # Lottie 动画 JSON
├── config/                        # 配置文件
│   ├── game.config.ts             # 游戏配置
│   ├── obs.config.ts              # OBS 配置
│   └── gift.config.ts             # 礼物映射配置
├── pnpm-workspace.yaml
├── tsconfig.base.json
└── package.json
```

---

## 2. 游戏引擎模块

### 2.1 模块职责

游戏引擎是整个系统的核心，负责：

- 斗地主完整规则实现（参照 `01-斗地主规则-AI版`）
- 游戏生命周期管理（发牌 → 叫地主 → 出牌 → 结算）
- 牌型识别与合法性校验
- 游戏状态维护与事件广播
- 礼物效果的牌面执行（接收来自礼物模块的指令）

### 2.2 核心类设计

```typescript
/** 游戏引擎 - 单局管理器 */
class GameEngine extends EventEmitter {
  private state: GameState;
  private deck: Deck;
  private players: Player[];
  private currentPlayerIndex: number;
  private roundId: string;

  constructor(config: GameConfig) {
    super();
    this.roundId = generateId();
    this.deck = new Deck();
    this.players = config.playerNames.map(name => new Player(name));
    this.state = GameState.WAITING;
  }

  /** 开始新一局 */
  async startRound(): Promise<void> {
    this.state = GameState.DEALING;
    this.emit('stateChange', this.state);

    // 洗牌发牌
    this.deck.shuffle();
    const hands = this.deck.deal();
    this.players.forEach((p, i) => p.setHand(hands[i]));
    const bottomCards = this.deck.getBottomCards();

    this.emit('dealt', {
      players: this.players.map(p => ({
        name: p.name,
        cardCount: p.hand.length
      })),
      bottomCards // 底牌暂不公开
    });

    // 进入叫地主阶段
    await this.biddingPhase();
  }
}
```

### 2.3 游戏状态机

```
┌─────────┐    发牌完成    ┌─────────┐   叫分结束   ┌─────────┐
│ WAITING  │ ────────────→ │ BIDDING  │ ───────────→ │ PLAYING  │
└─────────┘               └─────────┘              └────┬────┘
     ↑                         │                        │
     │                    无人叫地主                  有人出完牌
     │                    (重新发牌)                     │
     │                         │                   ┌────┴────┐
     └─────────────────────────┘                   │SETTLEMENT│
     ↑                                             └────┬────┘
     └──────────────── 结算完成，开始下一局 ──────────────┘
```

| 状态 | 枚举值 | 说明 |
|------|--------|------|
| WAITING | 0 | 等待开局 |
| DEALING | 1 | 发牌中 |
| BIDDING | 2 | 叫地主阶段 |
| PLAYING | 3 | 出牌阶段 |
| SETTLEMENT | 4 | 结算阶段 |

### 2.4 牌型识别器

```typescript
/** 牌型枚举 */
enum HandType {
  SINGLE = 'single',           // 单牌
  PAIR = 'pair',               // 对子
  TRIPLE = 'triple',           // 三条
  TRIPLE_ONE = 'triple_one',   // 三带一
  TRIPLE_TWO = 'triple_two',   // 三带二
  STRAIGHT = 'straight',       // 顺子 (≥5张)
  PAIR_STRAIGHT = 'pair_straight', // 连对 (≥3对)
  PLANE = 'plane',             // 飞机
  PLANE_WINGS = 'plane_wings', // 飞机带翅膀
  FOUR_TWO = 'four_two',       // 四带二
  BOMB = 'bomb',               // 炸弹
  ROCKET = 'rocket',           // 火箭 (双王)
  INVALID = 'invalid'          // 无效牌型
}

class HandTypeDetector {
  /** 识别一组牌的牌型 */
  detect(cards: Card[]): { type: HandType; rank: number } {
    const sorted = this.sortByRank(cards);
    const len = sorted.length;

    if (len === 0) return { type: HandType.INVALID, rank: 0 };
    if (len === 1) return { type: HandType.SINGLE, rank: sorted[0].rank };
    if (len === 2 && this.isRocket(sorted)) return { type: HandType.ROCKET, rank: 999 };
    if (len === 2 && this.isPair(sorted)) return { type: HandType.PAIR, rank: sorted[0].rank };
    if (len === 4 && this.isBomb(sorted)) return { type: HandType.BOMB, rank: sorted[0].rank };
    if (len >= 5 && this.isStraight(sorted)) return { type: HandType.STRAIGHT, rank: sorted[0].rank };
    // ... 其他牌型检测
    return { type: HandType.INVALID, rank: 0 };
  }

  /** 判断出牌是否能压过上家 */
  canBeat(current: Card[], previous: Card[]): boolean {
    const curr = this.detect(current);
    const prev = this.detect(previous);

    // 火箭压一切
    if (curr.type === HandType.ROCKET) return true;
    // 炸弹压非炸弹
    if (curr.type === HandType.BOMB && prev.type !== HandType.BOMB) return true;
    // 同类型比大小
    if (curr.type === prev.type && current.length === previous.length) {
      return curr.rank > prev.rank;
    }
    return false;
  }

  private sortByRank(cards: Card[]): Card[] { /* ... */ }
  private isRocket(cards: Card[]): boolean { /* ... */ }
  private isPair(cards: Card[]): boolean { /* ... */ }
  private isBomb(cards: Card[]): boolean { /* ... */ }
  private isStraight(cards: Card[]): boolean { /* ... */ }
}
```

### 2.5 发牌与洗牌

```typescript
class Deck {
  private cards: Card[] = [];
  private bottomCards: Card[] = [];

  constructor() {
    this.initDeck();
  }

  /** 初始化54张标准扑克牌 */
  private initDeck(): void {
    const suits = [CardSuit.SPADE, CardSuit.HEART, CardSuit.DIAMOND, CardSuit.CLUB];
    const ranks = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]; // 3~2

    for (const suit of suits) {
      for (const rank of ranks) {
        this.cards.push({ rank, suit, display: this.formatDisplay(rank, suit) });
      }
    }
    // 大小王
    this.cards.push({ rank: 16, suit: CardSuit.JOKER, display: '小王' });
    this.cards.push({ rank: 17, suit: CardSuit.JOKER, display: '大王' });
  }

  /** Fisher-Yates 洗牌算法 */
  shuffle(): void {
    for (let i = this.cards.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
    }
  }

  /** 发牌：每人17张，留3张底牌 */
  deal(): [Card[], Card[], Card[]] {
    const hand1 = this.cards.slice(0, 17);
    const hand2 = this.cards.slice(17, 34);
    const hand3 = this.cards.slice(34, 51);
    this.bottomCards = this.cards.slice(51, 54);
    return [hand1, hand2, hand3];
  }

  getBottomCards(): Card[] {
    return [...this.bottomCards];
  }

  private formatDisplay(rank: number, suit: CardSuit): string { /* ... */ }
}
```

### 2.6 叫地主流程

```typescript
interface BidAction {
  playerId: string;
  bid: 0 | 1 | 2 | 3; // 0=不叫
}

class BiddingManager {
  private bids: BidAction[] = [];
  private currentHighest: number = 0;
  private landlordId: string | null = null;

  /** 处理玩家叫分 */
  processBid(action: BidAction): { finished: boolean; landlordId?: string } {
    this.bids.push(action);

    if (action.bid > this.currentHighest) {
      this.currentHighest = action.bid;
      this.landlordId = action.playerId;
    }

    // 叫3分直接确定
    if (action.bid === 3) {
      return { finished: true, landlordId: action.playerId };
    }

    // 三人都表态完毕
    if (this.bids.length === 3) {
      if (this.currentHighest === 0) {
        return { finished: true }; // 全不叫，重新发牌
      }
      return { finished: true, landlordId: this.landlordId! };
    }

    return { finished: false };
  }

  getMultiplier(): number {
    return this.currentHighest || 1;
  }
}
```

---

## 3. AI 决策模块（CCCC 集成）

### 3.1 模块职责

AI 决策模块负责三个 AI 智能体的独立决策，包括：

- 叫地主决策（根据手牌质量评估是否叫地主及叫分值）
- 出牌决策（根据当前局面选择最优出牌策略）
- 人格化表达（生成符合角色性格的评论和情绪）
- 与 CCCC 多智能体框架的集成通信

### 3.2 CCCC 框架集成架构

```
┌─────────────────────────────────────────────────────┐
│                  CCCC 多智能体框架                      │
│                                                       │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐   │
│  │  AI-Alpha    │ │  AI-Beta     │ │  AI-Gamma    │   │
│  │  (烈焰哥)    │ │  (冰山姐)    │ │  (戏精弟)    │   │
│  │  进攻型策略   │ │  防守型策略   │ │  随机型策略   │   │
│  └──────┬──────┘ └──────┬──────┘ └──────┬──────┘   │
│         │               │               │            │
│  ┌──────┴───────────────┴───────────────┴──────┐    │
│  │            统一决策接口 (AIDecisionAPI)        │    │
│  └──────────────────────┬──────────────────────┘    │
└─────────────────────────┼───────────────────────────┘
                          │ JSON 消息协议
                          ▼
               ┌──────────────────┐
               │    游戏引擎       │
               │  GameEngine       │
               └──────────────────┘
```

### 3.3 AI 智能体角色定义

| 属性 | AI-Alpha (烈焰哥) | AI-Beta (冰山姐) | AI-Gamma (戏精弟) |
|------|-------------------|------------------|-------------------|
| 性格 | 激进、自信、爱嘲讽 | 冷静、理性、毒舌 | 搞笑、夸张、戏多 |
| 策略风格 | 进攻型，抢地主 | 防守型，善配合 | 随机型，出其不意 |
| 叫地主倾向 | 高（手牌中等即叫） | 低（仅好牌才叫） | 中（随机性强） |
| 出牌特点 | 优先出大牌压制 | 保守出牌，留后手 | 不按常理出牌 |
| 口头禅 | "这把我全要了！" | "你确定要这么出？" | "哎呀妈呀，炸了！" |

### 3.4 统一决策接口

```typescript
/** AI 决策请求类型 */
type AIRequest = BidRequest | PlayRequest;

interface BidRequest {
  type: 'BID_REQUEST';
  playerId: string;
  hand: Card[];
  currentHighestBid: number;
  bidHistory: BidAction[];
  availableBids: number[];
}

interface PlayRequest {
  type: 'PLAY_REQUEST';
  playerId: string;
  hand: Card[];
  isFreePlay: boolean;
  lastPlay: PlayedHand | null;
  playHistory: PlayRecord[];
  remainingCards: Record<string, number>;
  role: 'landlord' | 'farmer';
  teammates: string[];
}

/** AI 决策响应 */
interface AIResponse {
  type: 'BID_RESPONSE' | 'PLAY_RESPONSE';
  playerId: string;
  action: 'BID' | 'PLAY' | 'PASS';
  bid?: number;
  cards?: Card[];
  handType?: HandType;
  comment: string;
  emotion: EmotionType;
  strategyHint?: string;
}

type EmotionType = 'confident' | 'nervous' | 'excited' | 'angry'
  | 'thinking' | 'happy' | 'sad' | 'taunting';
```

### 3.5 AI 决策管理器

```typescript
class AIDecisionManager {
  private agents: Map<string, AIAgent> = new Map();
  private decisionTimeout = 5000; // 5秒决策超时

  constructor(config: AIConfig) {
    // 初始化三个 AI 智能体
    this.agents.set('AI-Alpha', new AggressiveAgent('AI-Alpha', config.alpha));
    this.agents.set('AI-Beta', new DefensiveAgent('AI-Beta', config.beta));
    this.agents.set('AI-Gamma', new ChaoticAgent('AI-Gamma', config.gamma));
  }

  /** 请求 AI 做出决策 */
  async requestDecision(request: AIRequest): Promise<AIResponse> {
    const agent = this.agents.get(request.playerId);
    if (!agent) throw new Error(`未知的 AI: ${request.playerId}`);

    // 带超时的决策请求
    const response = await Promise.race([
      agent.decide(request),
      this.timeoutFallback(request)
    ]);

    // 验证响应合法性
    this.validateResponse(response, request);
    return response;
  }

  /** 超时兜底策略 */
  private async timeoutFallback(request: AIRequest): Promise<AIResponse> {
    return new Promise((_, reject) =>
      setTimeout(() => reject(new Error('AI 决策超时')), this.decisionTimeout)
    );
  }

  /** 验证 AI 响应的合法性 */
  private validateResponse(response: AIResponse, request: AIRequest): void {
    if (response.type === 'PLAY_RESPONSE' && response.action === 'PLAY') {
      // 检查出的牌是否在手牌中
      const hand = (request as PlayRequest).hand;
      for (const card of response.cards!) {
        if (!hand.some(h => h.rank === card.rank && h.suit === card.suit)) {
          throw new Error(`非法出牌：${card.display} 不在手牌中`);
        }
      }
    }
  }
}
```

### 3.6 策略引擎基类

```typescript
/** AI 智能体抽象基类 */
abstract class AIAgent {
  readonly id: string;
  readonly personality: PersonalityConfig;
  protected handAnalyzer: HandAnalyzer;

  constructor(id: string, personality: PersonalityConfig) {
    this.id = id;
    this.personality = personality;
    this.handAnalyzer = new HandAnalyzer();
  }

  /** 核心决策方法（子类实现） */
  abstract decide(request: AIRequest): Promise<AIResponse>;

  /** 评估手牌质量（0-100分） */
  protected evaluateHand(hand: Card[]): number {
    let score = 0;
    const analysis = this.handAnalyzer.analyze(hand);

    score += analysis.bombs * 15;      // 炸弹加分
    score += analysis.rocket ? 20 : 0; // 火箭加分
    score += analysis.bigCards * 3;     // 大牌加分
    score += analysis.straights * 5;   // 连续牌型加分
    score -= analysis.singles * 2;     // 散牌扣分

    return Math.max(0, Math.min(100, score));
  }

  /** 生成人格化评论 */
  protected generateComment(
    situation: 'bid' | 'play' | 'pass' | 'win' | 'lose',
    context: any
  ): { comment: string; emotion: EmotionType } {
    const templates = this.personality.commentTemplates[situation];
    const template = templates[Math.floor(Math.random() * templates.length)];
    return {
      comment: this.fillTemplate(template, context),
      emotion: this.personality.emotionMap[situation]
    };
  }

  private fillTemplate(template: string, context: any): string {
    return template.replace(/\{(\w+)\}/g, (_, key) => context[key] ?? '');
  }
}
```

### 3.7 三种策略实现

```typescript
/** 进攻型策略 - AI-Alpha (烈焰哥) */
class AggressiveAgent extends AIAgent {
  async decide(request: AIRequest): Promise<AIResponse> {
    if (request.type === 'BID_REQUEST') return this.decideBid(request);
    return this.decidePlay(request as PlayRequest);
  }

  private decideBid(req: BidRequest): AIResponse {
    const handScore = this.evaluateHand(req.hand);
    let bid = 0;
    if (handScore >= 70) bid = 3;
    else if (handScore >= 55) bid = 2;
    else if (handScore >= 40) bid = 1; // 进攻型：40分即叫
    if (bid <= req.currentHighestBid) bid = 0;

    const { comment, emotion } = this.generateComment('bid', { bid });
    return { type: 'BID_RESPONSE', playerId: this.id, action: 'BID', bid, comment, emotion };
  }

  private decidePlay(req: PlayRequest): AIResponse {
    if (req.isFreePlay) {
      // 自由出牌：优先出大牌组合压制对手
      const bestPlay = this.findStrongestPlay(req.hand);
      if (bestPlay) {
        const { comment, emotion } = this.generateComment('play', {});
        return {
          type: 'PLAY_RESPONSE', playerId: this.id, action: 'PLAY',
          cards: bestPlay.cards, handType: bestPlay.type, comment, emotion
        };
      }
    } else {
      // 跟牌：尽量用最小的牌压过
      const beatPlay = this.findSmallestBeat(req.hand, req.lastPlay!);
      if (beatPlay) {
        const { comment, emotion } = this.generateComment('play', {});
        return {
          type: 'PLAY_RESPONSE', playerId: this.id, action: 'PLAY',
          cards: beatPlay.cards, handType: beatPlay.type, comment, emotion
        };
      }
    }
    const { comment, emotion } = this.generateComment('pass', {});
    return { type: 'PLAY_RESPONSE', playerId: this.id, action: 'PASS', cards: [], comment, emotion };
  }

  private findStrongestPlay(hand: Card[]): PlayedHand | null { /* ... */ }
  private findSmallestBeat(hand: Card[], lastPlay: PlayedHand): PlayedHand | null { /* ... */ }
}

/** 防守型策略 - AI-Beta (冰山姐) */
class DefensiveAgent extends AIAgent {
  async decide(request: AIRequest): Promise<AIResponse> {
    // 保守叫分（手牌 65+ 才叫），出牌留后手
    // 农民时优先配合队友，地主时稳扎稳打
    /* 实现逻辑类似 AggressiveAgent，但阈值更高、策略更保守 */
    return {} as AIResponse;
  }
}

/** 随机型策略 - AI-Gamma (戏精弟) */
class ChaoticAgent extends AIAgent {
  async decide(request: AIRequest): Promise<AIResponse> {
    // 决策带有随机扰动，30% 概率做出非最优但有趣的决策
    /* 实现逻辑包含随机因子，增加娱乐性 */
    return {} as AIResponse;
  }
}
```

### 3.8 手牌分析器

```typescript
/** 手牌结构分析结果 */
interface HandAnalysis {
  /** 炸弹数量 */
  bombs: number;
  /** 是否有火箭 */
  rocket: boolean;
  /** 大牌数量（A、2、王） */
  bigCards: number;
  /** 顺子组合数 */
  straights: number;
  /** 连对组合数 */
  pairStraights: number;
  /** 散牌数量 */
  singles: number;
  /** 对子数量 */
  pairs: number;
  /** 三条数量 */
  triples: number;
  /** 手牌控制力评分（0-100） */
  controlScore: number;
}

class HandAnalyzer {
  /** 全面分析手牌结构 */
  analyze(hand: Card[]): HandAnalysis {
    const rankCounts = this.countByRank(hand);
    const analysis: HandAnalysis = {
      bombs: 0, rocket: false, bigCards: 0,
      straights: 0, pairStraights: 0,
      singles: 0, pairs: 0, triples: 0,
      controlScore: 0
    };

    // 统计各牌型数量
    for (const [rank, count] of Object.entries(rankCounts)) {
      const r = Number(rank);
      if (count === 4) analysis.bombs++;
      else if (count === 3) analysis.triples++;
      else if (count === 2) analysis.pairs++;
      else if (count === 1) analysis.singles++;

      // 大牌统计（A=14, 2=15, 小王=16, 大王=17）
      if (r >= 14) analysis.bigCards += count;
    }

    // 火箭检测
    if (rankCounts[16] && rankCounts[17]) {
      analysis.rocket = true;
    }

    // 顺子检测
    analysis.straights = this.detectStraights(rankCounts);
    analysis.pairStraights = this.detectPairStraights(rankCounts);

    // 控制力评分
    analysis.controlScore = this.calculateControlScore(analysis, hand.length);

    return analysis;
  }

  /** 按点数统计张数 */
  private countByRank(hand: Card[]): Record<number, number> {
    const counts: Record<number, number> = {};
    for (const card of hand) {
      counts[card.rank] = (counts[card.rank] || 0) + 1;
    }
    return counts;
  }

  /** 检测可能的顺子数量 */
  private detectStraights(rankCounts: Record<number, number>): number {
    let count = 0;
    let consecutive = 0;
    // 顺子范围：3(=3) 到 A(=14)，不含2和王
    for (let r = 3; r <= 14; r++) {
      if (rankCounts[r] && rankCounts[r] >= 1) {
        consecutive++;
      } else {
        if (consecutive >= 5) count++;
        consecutive = 0;
      }
    }
    if (consecutive >= 5) count++;
    return count;
  }

  /** 检测可能的连对数量 */
  private detectPairStraights(rankCounts: Record<number, number>): number {
    let count = 0;
    let consecutive = 0;
    for (let r = 3; r <= 14; r++) {
      if (rankCounts[r] && rankCounts[r] >= 2) {
        consecutive++;
      } else {
        if (consecutive >= 3) count++;
        consecutive = 0;
      }
    }
    if (consecutive >= 3) count++;
    return count;
  }

  /** 计算手牌控制力评分 */
  private calculateControlScore(analysis: HandAnalysis, handSize: number): number {
    let score = 0;
    score += analysis.bombs * 15;
    score += analysis.rocket ? 20 : 0;
    score += analysis.bigCards * 3;
    score += analysis.straights * 5;
    score += analysis.pairStraights * 4;
    score += analysis.triples * 3;
    score -= analysis.singles * 2;
    // 手牌越少控制力越高（残局优势）
    if (handSize <= 5) score += 10;
    return Math.max(0, Math.min(100, score));
  }
}
```

### 3.9 CCCC 通信适配器

游戏引擎与 CCCC 多智能体框架之间通过适配器层解耦，支持本地模式（直接调用）和远程模式（WebSocket）两种通信方式。

```typescript
/** CCCC 通信适配器接口 */
interface CCCCAdapter {
  /** 发送决策请求并等待响应 */
  requestDecision(request: AIRequest): Promise<AIResponse>;
  /** 广播游戏状态更新 */
  broadcastState(state: GameStateSnapshot): void;
  /** 连接状态 */
  readonly connected: boolean;
}

/** 本地模式适配器（AI 逻辑与游戏引擎同进程） */
class LocalCCCCAdapter implements CCCCAdapter {
  private manager: AIDecisionManager;
  connected = true;

  constructor(config: AIConfig) {
    this.manager = new AIDecisionManager(config);
  }

  async requestDecision(request: AIRequest): Promise<AIResponse> {
    return this.manager.requestDecision(request);
  }

  broadcastState(state: GameStateSnapshot): void {
    this.manager.updateGameState(state);
  }
}

/** 远程模式适配器（AI 逻辑运行在独立 CCCC 进程） */
class RemoteCCCCAdapter implements CCCCAdapter {
  private ws: WebSocket | null = null;
  private pendingRequests = new Map<string, {
    resolve: (resp: AIResponse) => void;
    reject: (err: Error) => void;
    timer: NodeJS.Timeout;
  }>();
  connected = false;

  async connect(url: string): Promise<void> {
    this.ws = new WebSocket(url);
    this.ws.on('open', () => { this.connected = true; });
    this.ws.on('message', (data: Buffer) => {
      const msg = JSON.parse(data.toString());
      if (msg.type === 'DECISION_RESPONSE') {
        const pending = this.pendingRequests.get(msg.requestId);
        if (pending) {
          clearTimeout(pending.timer);
          pending.resolve(msg.response);
          this.pendingRequests.delete(msg.requestId);
        }
      }
    });
    this.ws.on('close', () => {
      this.connected = false;
      setTimeout(() => this.connect(url), 3000);
    });
  }

  async requestDecision(request: AIRequest): Promise<AIResponse> {
    const requestId = crypto.randomUUID();
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        this.pendingRequests.delete(requestId);
        reject(new Error('CCCC 远程决策超时'));
      }, 8000);
      this.pendingRequests.set(requestId, { resolve, reject, timer });
      this.ws?.send(JSON.stringify({
        type: 'DECISION_REQUEST', requestId, request
      }));
    });
  }

  broadcastState(state: GameStateSnapshot): void {
    this.ws?.send(JSON.stringify({ type: 'STATE_UPDATE', state }));
  }
}
```

### 3.10 AI 模块配置

```typescript
/** AI 模块完整配置 */
interface AIConfig {
  /** 通信模式 */
  mode: 'local' | 'remote';
  /** 远程模式 CCCC 服务地址 */
  remoteUrl?: string;
  /** 决策超时时间(ms) */
  decisionTimeout: number;
  /** 各 AI 角色配置 */
  alpha: PersonalityConfig;
  beta: PersonalityConfig;
  gamma: PersonalityConfig;
}

/** 人格配置 */
interface PersonalityConfig {
  name: string;
  strategyType: 'aggressive' | 'defensive' | 'chaotic';
  bidThreshold: number;
  randomFactor: number;
  commentTemplates: Record<string, string[]>;
  emotionMap: Record<string, EmotionType>;
}

// 默认配置
const DEFAULT_AI_CONFIG: AIConfig = {
  mode: 'local',
  decisionTimeout: 5000,
  alpha: {
    name: '烈焰哥', strategyType: 'aggressive',
    bidThreshold: 40, randomFactor: 0.1,
    commentTemplates: {
      bid: ['这把我全要了！', '叫{bid}分，不服来战！'],
      play: ['接招吧！', '大牌镇场！'],
      pass: ['这把我忍了...', '先让你嚣张一会'],
      win: ['赢了！太简单了！'], lose: ['下把赢回来！']
    },
    emotionMap: { bid: 'confident', play: 'excited', pass: 'angry', win: 'taunting', lose: 'angry' }
  },
  beta: {
    name: '冰山姐', strategyType: 'defensive',
    bidThreshold: 65, randomFactor: 0.05,
    commentTemplates: {
      bid: ['让我想想...', '这牌还行，叫{bid}分'],
      play: ['你确定要这么出？', '冷静分析一下'],
      pass: ['不急，让他先走', '静观其变'],
      win: ['意料之中'], lose: ['下次不会了']
    },
    emotionMap: { bid: 'thinking', play: 'confident', pass: 'thinking', win: 'happy', lose: 'sad' }
  },
  gamma: {
    name: '戏精弟', strategyType: 'chaotic',
    bidThreshold: 50, randomFactor: 0.3,
    commentTemplates: {
      bid: ['哎呀妈呀，我叫！', '赌一把！{bid}分！'],
      play: ['看我的骚操作！', '哎呀妈呀，炸了！'],
      pass: ['我装死~', '溜了溜了'],
      win: ['哈哈哈我赢了！'], lose: ['呜呜呜不玩了']
    },
    emotionMap: { bid: 'excited', play: 'excited', pass: 'nervous', win: 'happy', lose: 'sad' }
  }
};
```

---

## 4. 前端渲染模块

### 4.1 模块职责

前端渲染模块负责将游戏状态转化为可视化画面，包括：

- 牌桌场景渲染（背景、桌面、座位区域）
- 扑克牌渲染与动画（发牌、出牌、翻牌）
- AI 角色头像与表情系统
- 游戏信息 HUD（剩余牌数、倍数、计分板）
- 礼物特效渲染层
- OBS 覆盖层（直播信息、弹幕展示）

### 4.2 技术选型

| 技术 | 版本 | 用途 |
|------|------|------|
| React | 18+ | UI 组件框架、状态驱动渲染 |
| PixiJS | 7.x | WebGL 2D 渲染引擎（牌桌、扑克牌、粒子特效） |
| GSAP | 3.x | 高性能动画引擎（出牌动画、特效时间线） |
| Zustand | 4+ | 轻量级全局状态管理 |
| Howler.js | 2.x | 音效播放管理 |
| lottie-web | 5.x | Lottie 矢量动画渲染 |

#### 为什么选择 PixiJS 而非纯 Canvas 2D

| 对比项 | Canvas 2D | PixiJS (WebGL) |
|--------|-----------|----------------|
| 渲染性能 | 中等 | 高（GPU 加速） |
| 粒子系统 | 需手写 | 内置 @pixi/particle-emitter |
| 精灵图管理 | 手动 | 自动批处理、纹理图集 |
| 交互事件 | 需手写命中检测 | 内置事件系统 |
| 滤镜/混合模式 | 有限 | 丰富（模糊、发光、色调） |
| 学习曲线 | 低 | 中 |

> PixiJS 在粒子特效密集场景（礼物特效、出牌动画）下性能优势明显，且与 React 集成成熟。

### 4.3 前端组件架构

```
┌─────────────────────────────────────────────────────────┐
│  App.tsx                                                 │
│  ├── GameProvider (Zustand Store)                        │
│  ├── <GameTable />          ← PixiJS 渲染层（牌桌主体）  │
│  │   ├── <Background />     ← 牌桌背景纹理              │
│  │   ├── <PlayerSeat />×3   ← 三个玩家座位区域          │
│  │   │   ├── <Avatar />     ← AI 头像 + 表情            │
│  │   │   ├── <HandCards />  ← 手牌区域                  │
│  │   │   └── <InfoBadge />  ← 剩余牌数、角色标识        │
│  │   ├── <PlayZone />       ← 出牌区域（中央）          │
│  │   ├── <BottomCards />    ← 底牌展示区                │
│  │   └── <ParticleLayer />  ← 粒子特效层                │
│  ├── <HUD />                ← React DOM 层（信息面板）   │
│  │   ├── <ScoreBoard />     ← 计分板                    │
│  │   ├── <Multiplier />     ← 当前倍数显示              │
│  │   ├── <RoundInfo />      ← 局数、阶段信息            │
│  │   └── <Timer />          ← 出牌倒计时                │
│  ├── <EffectLayer />        ← 礼物特效覆盖层            │
│  │   ├── <ParticleEffect /> ← Canvas 2D 粒子            │
│  │   ├── <LottieEffect />   ← Lottie 动画              │
│  │   └── <ScreenShake />    ← 屏幕震动效果              │
│  └── <Overlay />            ← OBS 覆盖层                │
│      ├── <DanmakuBar />     ← 弹幕展示                  │
│      ├── <GiftNotify />     ← 礼物通知                  │
│      └── <AIComment />      ← AI 发言气泡               │
└─────────────────────────────────────────────────────────┘
```

### 4.4 Zustand 状态管理

```typescript
import { create } from 'zustand';

/** 游戏全局状态 */
interface GameStore {
  // 游戏状态
  phase: GamePhase;
  roundId: string;
  multiplier: number;
  roundNumber: number;

  // 玩家状态
  players: PlayerState[];
  landlordId: string | null;
  currentPlayerId: string | null;

  // 牌面状态
  bottomCards: Card[];
  lastPlay: PlayedHand | null;
  playHistory: PlayRecord[];

  // UI 状态
  showBottomCards: boolean;
  activeEffects: ActiveEffect[];
  aiComments: AICommentData[];

  // Actions
  setPhase: (phase: GamePhase) => void;
  updatePlayer: (id: string, data: Partial<PlayerState>) => void;
  setLastPlay: (play: PlayedHand | null) => void;
  addEffect: (effect: ActiveEffect) => void;
  removeEffect: (id: string) => void;
  addAIComment: (comment: AICommentData) => void;
  resetRound: () => void;
}

interface PlayerState {
  id: string;
  name: string;
  role: 'landlord' | 'farmer' | null;
  handCount: number;
  hand: Card[];       // 仅当前视角玩家可见
  score: number;
  emotion: EmotionType;
  isThinking: boolean;
}

const useGameStore = create<GameStore>((set, get) => ({
  phase: 'WAITING',
  roundId: '',
  multiplier: 1,
  roundNumber: 0,
  players: [],
  landlordId: null,
  currentPlayerId: null,
  bottomCards: [],
  lastPlay: null,
  playHistory: [],
  showBottomCards: false,
  activeEffects: [],
  aiComments: [],

  setPhase: (phase) => set({ phase }),
  updatePlayer: (id, data) => set((state) => ({
    players: state.players.map(p =>
      p.id === id ? { ...p, ...data } : p
    )
  })),
  setLastPlay: (play) => set({ lastPlay: play }),
  addEffect: (effect) => set((state) => ({
    activeEffects: [...state.activeEffects, effect]
  })),
  removeEffect: (id) => set((state) => ({
    activeEffects: state.activeEffects.filter(e => e.id !== id)
  })),
  addAIComment: (comment) => set((state) => ({
    aiComments: [...state.aiComments.slice(-4), comment] // 最多保留5条
  })),
  resetRound: () => set({
    phase: 'WAITING', lastPlay: null, playHistory: [],
    bottomCards: [], showBottomCards: false, activeEffects: []
  })
}));
```

### 4.5 PixiJS 游戏渲染器

```typescript
import { Application, Container, Sprite, Texture } from 'pixi.js';

/** 游戏渲染器 - 管理 PixiJS 画布与场景图 */
class GameRenderer {
  private app: Application;
  private layers: Map<string, Container> = new Map();

  /** 画布尺寸常量 */
  static readonly CANVAS_WIDTH = 1920;
  static readonly CANVAS_HEIGHT = 1080;

  constructor(canvasContainer: HTMLElement) {
    this.app = new Application({
      width: GameRenderer.CANVAS_WIDTH,
      height: GameRenderer.CANVAS_HEIGHT,
      backgroundColor: 0x1a5c2a, // 牌桌绿色
      antialias: true,
      resolution: window.devicePixelRatio || 1,
      autoDensity: true,
    });
    canvasContainer.appendChild(this.app.view as HTMLCanvasElement);
    this.initLayers();
  }

  /** 初始化渲染层级（从下到上） */
  private initLayers(): void {
    const layerOrder = [
      'background',    // 牌桌背景纹理
      'table',         // 桌面装饰（座位标记、区域线）
      'cards',         // 手牌 & 出牌区域
      'avatars',       // AI 头像 & 表情
      'ui',            // 剩余牌数、角色标识等 HUD
      'effects',       // 粒子特效（出牌动画、炸弹爆炸）
      'gift',          // 礼物特效层
    ];

    for (const name of layerOrder) {
      const container = new Container();
      container.name = name;
      this.app.stage.addChild(container);
      this.layers.set(name, container);
    }
  }

  /** 获取指定渲染层 */
  getLayer(name: string): Container {
    const layer = this.layers.get(name);
    if (!layer) throw new Error(`未知渲染层: ${name}`);
    return layer;
  }

  /** 更新牌桌背景 */
  setBackground(texture: Texture): void {
    const bg = this.getLayer('background');
    bg.removeChildren();
    const sprite = new Sprite(texture);
    sprite.width = GameRenderer.CANVAS_WIDTH;
    sprite.height = GameRenderer.CANVAS_HEIGHT;
    bg.addChild(sprite);
  }

  /** 帧更新回调注册 */
  onTick(callback: (delta: number) => void): void {
    this.app.ticker.add(callback);
  }

  /** 销毁渲染器，释放 GPU 资源 */
  destroy(): void {
    this.app.destroy(true, { children: true, texture: true });
  }
}
```

### 4.6 扑克牌精灵管理

```typescript
import { Sprite, Texture, Container, Assets } from 'pixi.js';

/** 扑克牌纹理图集管理器 */
class CardTextureAtlas {
  private textures: Map<string, Texture> = new Map();
  private backTexture: Texture | null = null;
  private loaded = false;

  /** 预加载所有牌面纹理（启动时调用） */
  async preload(): Promise<void> {
    // 加载纹理图集（所有牌面合并为一张 spritesheet）
    const sheet = await Assets.load('/assets/cards/cards-atlas.json');

    // 普通牌：suit_rank 格式（如 spade_3, heart_A）
    const suits = ['spade', 'heart', 'diamond', 'club'];
    const ranks = ['3','4','5','6','7','8','9','10','J','Q','K','A','2'];
    for (const suit of suits) {
      for (const rank of ranks) {
        const key = `${suit}_${rank}`;
        this.textures.set(key, sheet.textures[key]);
      }
    }

    // 大小王
    this.textures.set('small_joker', sheet.textures['small_joker']);
    this.textures.set('big_joker', sheet.textures['big_joker']);

    // 牌背
    this.backTexture = sheet.textures['card_back'];
    this.loaded = true;
  }

  /** 根据 Card 对象获取正面纹理 */
  getTexture(card: Card): Texture {
    if (!this.loaded) throw new Error('纹理图集未加载');
    const key = this.cardToKey(card);
    return this.textures.get(key) ?? Texture.EMPTY;
  }

  /** 获取牌背纹理 */
  getBackTexture(): Texture {
    if (!this.backTexture) throw new Error('纹理图集未加载');
    return this.backTexture;
  }

  private cardToKey(card: Card): string {
    if (card.rank === 16) return 'small_joker';
    if (card.rank === 17) return 'big_joker';
    const suitMap: Record<string, string> = {
      '♠': 'spade', '♥': 'heart', '♦': 'diamond', '♣': 'club'
    };
    const rankMap: Record<number, string> = {
      3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'10',
      11:'J',12:'Q',13:'K',14:'A',15:'2'
    };
    return `${suitMap[card.suit]}_${rankMap[card.rank]}`;
  }
}
```

```typescript
/** 单张扑克牌精灵 */
class CardSprite extends Container {
  private frontSprite: Sprite;
  private backSprite: Sprite;
  private _faceUp: boolean = false;

  /** 牌面标准尺寸 */
  static readonly CARD_WIDTH = 105;
  static readonly CARD_HEIGHT = 150;

  constructor(
    private card: Card,
    private atlas: CardTextureAtlas
  ) {
    super();

    // 正面
    this.frontSprite = new Sprite(atlas.getTexture(card));
    this.frontSprite.width = CardSprite.CARD_WIDTH;
    this.frontSprite.height = CardSprite.CARD_HEIGHT;
    this.frontSprite.visible = false;

    // 背面
    this.backSprite = new Sprite(atlas.getBackTexture());
    this.backSprite.width = CardSprite.CARD_WIDTH;
    this.backSprite.height = CardSprite.CARD_HEIGHT;
    this.backSprite.visible = true;

    this.addChild(this.backSprite, this.frontSprite);

    // 设置锚点为中心（便于旋转/缩放动画）
    this.pivot.set(CardSprite.CARD_WIDTH / 2, CardSprite.CARD_HEIGHT / 2);
  }

  /** 翻牌（切换正反面） */
  setFaceUp(faceUp: boolean): void {
    this._faceUp = faceUp;
    this.frontSprite.visible = faceUp;
    this.backSprite.visible = !faceUp;
  }

  get faceUp(): boolean { return this._faceUp; }
  getCard(): Card { return this.card; }
}
```

### 4.7 动画系统（GSAP 集成）

```typescript
import gsap from 'gsap';

/** 座位位置常量（1920×1080 画布坐标） */
const SEAT_POSITIONS = {
  bottom: { x: 960, y: 920, handY: 980 },   // 当前视角玩家（底部）
  left:   { x: 180, y: 450, handY: 400 },   // 左家
  right:  { x: 1740, y: 450, handY: 400 },  // 右家
} as const;

/** 出牌区域中心坐标 */
const PLAY_ZONE = { x: 960, y: 500 };

/** 牌堆位置（发牌起点） */
const DECK_POSITION = { x: 960, y: 400 };

/** 游戏动画管理器 */
class GameAnimator {
  private timeline: gsap.core.Timeline | null = null;

  /** 发牌动画：牌从牌堆飞向三个玩家 */
  async animateDeal(
    cardSprites: CardSprite[][],  // [玩家0的牌[], 玩家1的牌[], 玩家2的牌[]]
    seats: ('bottom' | 'left' | 'right')[]
  ): Promise<void> {
    this.timeline = gsap.timeline();

    for (let i = 0; i < 17; i++) {
      for (let s = 0; s < 3; s++) {
        const sprite = cardSprites[s][i];
        const seat = SEAT_POSITIONS[seats[s]];
        const offsetX = (i - 8) * 30; // 手牌扇形展开偏移

        // 初始位置：牌堆中心
        sprite.x = DECK_POSITION.x;
        sprite.y = DECK_POSITION.y;
        sprite.alpha = 0;
        sprite.scale.set(0.5);

        this.timeline.to(sprite, {
          x: seat.x + offsetX,
          y: seat.handY,
          alpha: 1,
          scaleX: 1,
          scaleY: 1,
          duration: 0.15,
          ease: 'power2.out',
        }, `deal+=${i * 0.06 + s * 0.02}`);
      }
    }

    return this.timeline.then();
  }

  /** 出牌动画：牌从手牌区飞向出牌区 */
  async animatePlay(
    cards: CardSprite[],
    fromSeat: 'bottom' | 'left' | 'right'
  ): Promise<void> {
    const tl = gsap.timeline();

    cards.forEach((card, i) => {
      const targetX = PLAY_ZONE.x + (i - (cards.length - 1) / 2) * 40;
      const targetY = PLAY_ZONE.y;

      tl.to(card, {
        x: targetX,
        y: targetY,
        scaleX: 1.1,
        scaleY: 1.1,
        duration: 0.3,
        ease: 'back.out(1.2)',
      }, i * 0.05);

      // 翻牌（如果是背面）
      if (!card.faceUp) {
        tl.call(() => card.setFaceUp(true), [], i * 0.05 + 0.15);
      }
    });

    // 落地后轻微回弹
    tl.to(cards, {
      scaleX: 1,
      scaleY: 1,
      duration: 0.15,
      ease: 'power1.in',
    });

    return tl.then();
  }

  /** 翻牌动画（3D 翻转效果模拟） */
  async animateFlip(card: CardSprite): Promise<void> {
    const tl = gsap.timeline();

    // 压缩 X 轴模拟翻转前半段
    tl.to(card, { scaleX: 0, duration: 0.15, ease: 'power1.in' });
    // 切换正反面
    tl.call(() => card.setFaceUp(!card.faceUp));
    // 展开 X 轴模拟翻转后半段
    tl.to(card, { scaleX: 1, duration: 0.15, ease: 'power1.out' });

    return tl.then();
  }

  /** 炸弹特效动画 */
  async animateBomb(position: { x: number; y: number }): Promise<void> {
    const tl = gsap.timeline();

    // 屏幕震动
    const stage = document.querySelector('.game-canvas') as HTMLElement;
    if (stage) {
      tl.to(stage, {
        x: '+=8', duration: 0.05, yoyo: true, repeat: 5, ease: 'none',
      }, 0);
      tl.to(stage, {
        y: '+=5', duration: 0.07, yoyo: true, repeat: 3, ease: 'none',
      }, 0);
    }

    return tl.then();
  }

  /** 停止所有正在播放的动画 */
  killAll(): void {
    this.timeline?.kill();
    gsap.killTweensOf('*');
  }
}
```

### 4.8 React 与 PixiJS 桥接

React 负责 DOM 层 UI（HUD、弹幕、覆盖层），PixiJS 负责 Canvas 层游戏画面。两者通过 Zustand Store 共享状态，通过 React ref 持有 PixiJS 实例。

```typescript
import { useEffect, useRef } from 'react';

/** PixiJS 画布容器组件 */
function GameCanvas() {
  const containerRef = useRef<HTMLDivElement>(null);
  const rendererRef = useRef<GameRenderer | null>(null);
  const animatorRef = useRef<GameAnimator | null>(null);

  // 监听游戏状态变化，驱动 PixiJS 渲染
  const phase = useGameStore((s) => s.phase);
  const lastPlay = useGameStore((s) => s.lastPlay);

  useEffect(() => {
    if (!containerRef.current) return;

    // 初始化 PixiJS 渲染器
    const renderer = new GameRenderer(containerRef.current);
    const animator = new GameAnimator();
    rendererRef.current = renderer;
    animatorRef.current = animator;

    return () => {
      animator.killAll();
      renderer.destroy();
    };
  }, []);

  // 出牌时触发动画
  useEffect(() => {
    if (lastPlay && animatorRef.current) {
      // 由 Zustand 状态变化驱动 PixiJS 动画
      // 具体的 CardSprite 实例由渲染器内部管理
    }
  }, [lastPlay]);

  return (
    <div
      ref={containerRef}
      className="game-canvas"
      style={{ width: 1920, height: 1080, position: 'relative' }}
    />
  );
}
```

#### 渲染架构分层示意

```
┌─────────────────────────────────────────────┐
│  React DOM 层 (z-index: 10)                  │
│  ├── HUD (计分板、倍数、倒计时)               │
│  ├── AI 发言气泡                              │
│  ├── 礼物通知横幅                             │
│  └── OBS 覆盖层信息                           │
├─────────────────────────────────────────────┤
│  PixiJS Canvas 层 (z-index: 1)               │
│  ├── gift      礼物粒子特效                   │
│  ├── effects   出牌/炸弹特效                  │
│  ├── ui        牌数标签、角色标识              │
│  ├── avatars   AI 头像精灵                    │
│  ├── cards     手牌 & 出牌区                  │
│  ├── table     桌面装饰                       │
│  └── background 牌桌背景纹理                  │
└─────────────────────────────────────────────┘
```

### 4.9 音效管理器

```typescript
import { Howl, Howler } from 'howler';

/** 音效资源定义 */
const SFX_MANIFEST: Record<string, { src: string; volume: number }> = {
  card_deal:    { src: '/assets/sfx/card_deal.mp3',    volume: 0.6 },
  card_play:    { src: '/assets/sfx/card_play.mp3',    volume: 0.7 },
  card_flip:    { src: '/assets/sfx/card_flip.mp3',    volume: 0.5 },
  bomb:         { src: '/assets/sfx/explosion.mp3',    volume: 0.9 },
  rocket:       { src: '/assets/sfx/rocket_launch.mp3',volume: 0.9 },
  bid_call:     { src: '/assets/sfx/bid_call.mp3',     volume: 0.7 },
  bid_pass:     { src: '/assets/sfx/bid_pass.mp3',     volume: 0.5 },
  win:          { src: '/assets/sfx/win_fanfare.mp3',  volume: 0.8 },
  lose:         { src: '/assets/sfx/lose_sad.mp3',     volume: 0.6 },
  timer_tick:   { src: '/assets/sfx/tick.mp3',         volume: 0.4 },
  gift_arrive:  { src: '/assets/sfx/cheer_ding.mp3',   volume: 0.6 },
};

class SoundManager {
  private sounds: Map<string, Howl> = new Map();
  private bgm: Howl | null = null;
  private _muted = false;

  /** 预加载所有音效（启动时调用） */
  async preload(): Promise<void> {
    const promises: Promise<void>[] = [];

    for (const [key, config] of Object.entries(SFX_MANIFEST)) {
      const howl = new Howl({
        src: [config.src],
        volume: config.volume,
        preload: true,
      });
      this.sounds.set(key, howl);
      promises.push(
        new Promise((resolve) => {
          howl.once('load', () => resolve());
          howl.once('loaderror', () => {
            console.warn(`[Sound] 加载失败: ${key}`);
            resolve(); // 不阻塞启动
          });
        })
      );
    }

    await Promise.all(promises);
  }

  /** 播放音效 */
  play(key: string): void {
    if (this._muted) return;
    const sound = this.sounds.get(key);
    if (sound) sound.play();
  }

  /** 播放背景音乐（循环） */
  playBGM(src: string, volume = 0.3): void {
    this.stopBGM();
    this.bgm = new Howl({ src: [src], volume, loop: true });
    if (!this._muted) this.bgm.play();
  }

  /** 停止背景音乐 */
  stopBGM(): void {
    this.bgm?.stop();
    this.bgm?.unload();
    this.bgm = null;
  }

  /** 全局静音切换 */
  toggleMute(): boolean {
    this._muted = !this._muted;
    Howler.mute(this._muted);
    return this._muted;
  }

  get muted(): boolean { return this._muted; }
}
```

---

## 5. 直播推流模块

> 对应策划文档：`04-OBS直播技术方案`
> 本模块负责游戏画面到抖音直播的完整推流链路，包括 OBS 自动化控制、场景切换、推流健康监控、TTS 解说集成。

### 5.1 模块职责

```
直播推流模块
├── OBS WebSocket 控制器    ← 远程控制 OBS Studio
├── 场景自动切换管理器      ← 根据游戏阶段切换 OBS 场景
├── 推流健康监控            ← 实时监控推流质量与自动降级
├── TTS 解说引擎            ← AI 解说文本生成与语音合成
└── 断流容灾守卫            ← 断流检测、自动重连、备用链路
```

### 5.2 OBS WebSocket 控制器

基于 `obs-websocket-js` 5.x 封装，提供类型安全的 OBS 远程控制能力。与 `04-OBS直播技术方案 §7` 的 API 设计对齐。

```typescript
import OBSWebSocket from 'obs-websocket-js';
import { EventEmitter } from 'eventemitter3';

/** OBS 连接配置 */
interface OBSConfig {
  /** WebSocket 地址，默认 ws://localhost:4455 */
  url: string;
  /** 认证密码 */
  password: string;
  /** 自动重连间隔(ms)，默认 5000 */
  reconnectInterval: number;
  /** 最大重连次数，默认 20 */
  maxReconnectAttempts: number;
}

/** 推流状态快照 */
interface StreamStatus {
  active: boolean;
  reconnecting: boolean;
  durationMs: number;
  congestion: number;
  bytesSent: number;
  skippedFrames: number;
  totalFrames: number;
}

/** OBS 控制器事件 */
interface OBSControllerEvents {
  connected: () => void;
  disconnected: (reason: string) => void;
  streamStarted: () => void;
  streamStopped: () => void;
  sceneChanged: (sceneName: string) => void;
  error: (err: Error) => void;
}

class OBSController extends EventEmitter<OBSControllerEvents> {
  private obs: OBSWebSocket;
  private config: OBSConfig;
  private connected = false;
  private reconnectCount = 0;
  private reconnectTimer: ReturnType<typeof setTimeout> | null = null;

  constructor(config: Partial<OBSConfig> = {}) {
    super();
    this.obs = new OBSWebSocket();
    this.config = {
      url: 'ws://localhost:4455',
      password: '',
      reconnectInterval: 5000,
      maxReconnectAttempts: 20,
      ...config,
    };
    this.setupEventListeners();
  }

  /** 建立连接 */
  async connect(): Promise<void> {
    try {
      await this.obs.connect(this.config.url, this.config.password);
      this.connected = true;
      this.reconnectCount = 0;
      this.emit('connected');
    } catch (err) {
      this.emit('error', err as Error);
      this.scheduleReconnect();
    }
  }

  /** 切换场景（与 04 §7.4 switchScene 对齐） */
  async switchScene(sceneName: string): Promise<void> {
    this.assertConnected();
    await this.obs.call('SetCurrentProgramScene', { sceneName });
    this.emit('sceneChanged', sceneName);
  }

  /** 显示/隐藏指定源 */
  async setSourceVisible(
    sceneName: string,
    sourceName: string,
    visible: boolean,
  ): Promise<void> {
    this.assertConnected();
    const { sceneItemId } = await this.obs.call('GetSceneItemId', {
      sceneName,
      sourceName,
    });
    await this.obs.call('SetSceneItemEnabled', {
      sceneName,
      sceneItemId,
      sceneItemEnabled: visible,
    });
  }

  /** 刷新浏览器源（强制无缓存刷新） */
  async refreshBrowserSource(sourceName: string): Promise<void> {
    this.assertConnected();
    await this.obs.call('PressInputPropertiesButton', {
      inputName: sourceName,
      propertyName: 'refreshnocache',
    });
  }

  /** 更新浏览器源 URL */
  async setBrowserSourceURL(sourceName: string, url: string): Promise<void> {
    this.assertConnected();
    await this.obs.call('SetInputSettings', {
      inputName: sourceName,
      inputSettings: { url },
    });
  }

  /** 获取推流状态 */
  async getStreamStatus(): Promise<StreamStatus> {
    this.assertConnected();
    const s = await this.obs.call('GetStreamStatus');
    return {
      active: s.outputActive,
      reconnecting: s.outputReconnecting,
      durationMs: s.outputDuration,
      congestion: s.outputCongestion,
      bytesSent: s.outputBytes,
      skippedFrames: s.outputSkippedFrames,
      totalFrames: s.outputTotalFrames,
    };
  }

  /** 开始推流 */
  async startStream(): Promise<void> {
    this.assertConnected();
    await this.obs.call('StartStream');
  }

  /** 停止推流 */
  async stopStream(): Promise<void> {
    this.assertConnected();
    await this.obs.call('StopStream');
  }

  /** 截图保存（精彩瞬间） */
  async saveScreenshot(
    sourceName: string,
    filePath: string,
    format: 'png' | 'jpg' = 'png',
  ): Promise<void> {
    this.assertConnected();
    await this.obs.call('SaveSourceScreenshot', {
      sourceName,
      imageFormat: format,
      imageFilePath: filePath,
    });
  }

  /** 断开连接 */
  async disconnect(): Promise<void> {
    if (this.reconnectTimer) clearTimeout(this.reconnectTimer);
    this.obs.disconnect();
    this.connected = false;
  }

  // ── 内部方法 ──

  private setupEventListeners(): void {
    this.obs.on('ConnectionClosed', () => {
      this.connected = false;
      this.emit('disconnected', 'connection_closed');
      this.scheduleReconnect();
    });
    this.obs.on('StreamStateChanged', (ev) => {
      if (ev.outputActive) this.emit('streamStarted');
      else this.emit('streamStopped');
    });
  }

  private scheduleReconnect(): void {
    if (this.reconnectCount >= this.config.maxReconnectAttempts) {
      this.emit('error', new Error('OBS 重连次数已达上限'));
      return;
    }
    this.reconnectCount++;
    const delay = this.config.reconnectInterval * Math.min(this.reconnectCount, 5);
    this.reconnectTimer = setTimeout(() => this.connect(), delay);
  }

  private assertConnected(): void {
    if (!this.connected) throw new Error('OBS 未连接');
  }
}
```

### 5.3 场景自动切换管理器

监听游戏引擎状态变化，自动切换 OBS 场景。场景名称与 `04-OBS直播技术方案 §5` 的 5 个核心场景一一对应。

```typescript
/** OBS 场景名称常量（与 04 §5.1 对齐） */
const OBS_SCENES = {
  WAITING:    '开场等待',     // S1
  BIDDING:    '叫地主阶段',   // S2
  PLAYING:    '对局进行中',   // S3
  SETTLEMENT: '结算画面',     // S4
  BREAK:      '中场休息',     // S5
} as const;

type SceneName = typeof OBS_SCENES[keyof typeof OBS_SCENES];

/** 场景切换转场配置（与 04 §5.3 对齐） */
const SCENE_TRANSITIONS: Record<string, { target: SceneName; delayMs: number }> = {
  DEALING:    { target: OBS_SCENES.BIDDING,    delayMs: 0 },
  BIDDING:    { target: OBS_SCENES.BIDDING,    delayMs: 0 },
  PLAYING:    { target: OBS_SCENES.PLAYING,    delayMs: 0 },
  ROUND_END:  { target: OBS_SCENES.SETTLEMENT, delayMs: 0 },
  WAITING:    { target: OBS_SCENES.WAITING,    delayMs: 0 },
};

/** 结算画面停留时间(ms)，之后自动切回等待 */
const SETTLEMENT_DISPLAY_DURATION = 8000;

class SceneManager {
  private obs: OBSController;
  private currentScene: SceneName = OBS_SCENES.WAITING;
  private settlementTimer: ReturnType<typeof setTimeout> | null = null;
  private roundCount = 0;
  /** 每隔 N 局插入中场休息 */
  private breakInterval = 5;

  constructor(obs: OBSController) {
    this.obs = obs;
  }

  /** 根据游戏阶段自动切换场景 */
  async onGamePhaseChange(phase: string): Promise<void> {
    // 清除结算定时器
    if (this.settlementTimer) {
      clearTimeout(this.settlementTimer);
      this.settlementTimer = null;
    }

    const transition = SCENE_TRANSITIONS[phase];
    if (!transition) return;

    // 结算阶段特殊处理：停留后自动切回
    if (phase === 'ROUND_END') {
      await this.switchTo(OBS_SCENES.SETTLEMENT);
      this.roundCount++;

      this.settlementTimer = setTimeout(async () => {
        // 判断是否插入中场休息
        if (this.roundCount % this.breakInterval === 0) {
          await this.switchTo(OBS_SCENES.BREAK);
        } else {
          await this.switchTo(OBS_SCENES.WAITING);
        }
      }, SETTLEMENT_DISPLAY_DURATION);
      return;
    }

    await this.switchTo(transition.target);
  }

  /** 礼物特效源显隐控制 */
  async showGiftEffect(durationMs: number = 3000): Promise<void> {
    await this.obs.setSourceVisible(OBS_SCENES.PLAYING, '礼物特效层', true);
    setTimeout(async () => {
      await this.obs.setSourceVisible(OBS_SCENES.PLAYING, '礼物特效层', false);
    }, durationMs);
  }

  /** 手动切换到中场休息 */
  async enterBreak(): Promise<void> {
    await this.switchTo(OBS_SCENES.BREAK);
  }

  /** 从中场休息恢复 */
  async exitBreak(): Promise<void> {
    await this.switchTo(OBS_SCENES.WAITING);
  }

  private async switchTo(scene: SceneName): Promise<void> {
    if (this.currentScene === scene) return;
    await this.obs.switchScene(scene);
    this.currentScene = scene;
  }
}
```

### 5.4 推流健康监控

实时监控推流质量指标，当指标恶化时自动触发降级策略。阈值与 `04-OBS直播技术方案 §8.2` 对齐。

```typescript
/** 推流质量等级 */
enum StreamHealthLevel {
  HEALTHY = 'healthy',
  WARNING = 'warning',
  CRITICAL = 'critical',
}

/** 降级等级（与 04 §9.3 对齐） */
enum DegradeLevel {
  NONE = 0,       // 正常
  L1 = 1,         // 关闭覆盖层特效
  L2 = 2,         // 降帧率 30→24fps
  L3 = 3,         // 降分辨率 1080p→720p
  L4 = 4,         // 降码率至 2000Kbps
  L5 = 5,         // 静态画面+音频
}

class StreamHealthMonitor {
  private obs: OBSController;
  private pollInterval: ReturnType<typeof setInterval> | null = null;
  private currentLevel = DegradeLevel.NONE;
  private prevSkippedFrames = 0;
  private prevTotalFrames = 0;

  /** 监控轮询间隔(ms) */
  private readonly POLL_MS = 10_000;

  /** 丢帧率阈值 */
  private readonly WARN_DROP_RATE = 0.001;   // 0.1%
  private readonly CRIT_DROP_RATE = 0.01;    // 1%

  constructor(obs: OBSController) {
    this.obs = obs;
  }

  /** 启动监控 */
  start(): void {
    this.pollInterval = setInterval(() => this.check(), this.POLL_MS);
  }

  /** 停止监控 */
  stop(): void {
    if (this.pollInterval) {
      clearInterval(this.pollInterval);
      this.pollInterval = null;
    }
  }

  /** 单次健康检查 */
  private async check(): Promise<void> {
    try {
      const status = await this.obs.getStreamStatus();
      if (!status.active) return;

      // 计算区间丢帧率
      const deltaSkipped = status.skippedFrames - this.prevSkippedFrames;
      const deltaTotal = status.totalFrames - this.prevTotalFrames;
      this.prevSkippedFrames = status.skippedFrames;
      this.prevTotalFrames = status.totalFrames;

      if (deltaTotal === 0) return;
      const dropRate = deltaSkipped / deltaTotal;

      // 判定健康等级
      let health: StreamHealthLevel;
      if (dropRate > this.CRIT_DROP_RATE) {
        health = StreamHealthLevel.CRITICAL;
      } else if (dropRate > this.WARN_DROP_RATE) {
        health = StreamHealthLevel.WARNING;
      } else {
        health = StreamHealthLevel.HEALTHY;
      }

      // 执行降级/恢复
      await this.adjustDegradeLevel(health);

      console.log(
        `[StreamHealth] dropRate=${(dropRate * 100).toFixed(3)}% ` +
        `health=${health} degrade=L${this.currentLevel}`,
      );
    } catch {
      // OBS 断连时静默跳过
    }
  }

  /** 根据健康等级调整降级策略 */
  private async adjustDegradeLevel(health: StreamHealthLevel): Promise<void> {
    if (health === StreamHealthLevel.CRITICAL && this.currentLevel < DegradeLevel.L5) {
      this.currentLevel++;
      console.warn(`[StreamHealth] 升级降级至 L${this.currentLevel}`);
      await this.applyDegrade(this.currentLevel);
    } else if (health === StreamHealthLevel.HEALTHY && this.currentLevel > DegradeLevel.NONE) {
      this.currentLevel--;
      console.info(`[StreamHealth] 恢复降级至 L${this.currentLevel}`);
      await this.applyDegrade(this.currentLevel);
    }
  }

  /** 执行具体降级操作（需配合 OBS Profile 预设） */
  private async applyDegrade(level: DegradeLevel): Promise<void> {
    // 实际降级通过切换 OBS Profile 或调整编码参数实现
    // 此处为逻辑框架，具体 OBS API 调用需根据 Profile 预设配置
    switch (level) {
      case DegradeLevel.L1:
        await this.obs.setSourceVisible('对局进行中', '礼物特效层', false);
        break;
      case DegradeLevel.L2:
        // 通过 SetVideoSettings 降帧率（需 OBS 30.2+）
        break;
      case DegradeLevel.L3:
        // 切换到 720p Profile
        break;
      case DegradeLevel.L4:
        // 调整编码器码率
        break;
      case DegradeLevel.L5:
        // 切换到静态画面场景
        await this.obs.switchScene('应急静态画面');
        break;
    }
  }
}
```

### 5.5 TTS 解说引擎

AI 解说是直播观赏性的核心增强。采用 Edge TTS（免费、低延迟、高音质）作为主引擎，与 `04-OBS直播技术方案 §6.4` 的 TTS 方案对齐。

#### 5.5.1 解说文本生成器

```typescript
/** 解说事件类型 */
type CommentaryEvent =
  | { type: 'ROUND_START'; landlordId: string; bidScore: number }
  | { type: 'CARD_PLAYED'; playerId: string; handType: string; cards: string[]; remaining: number }
  | { type: 'PASS'; playerId: string }
  | { type: 'BOMB'; playerId: string }
  | { type: 'ROCKET'; playerId: string }
  | { type: 'SPRING'; winnerId: string }
  | { type: 'ROUND_END'; winnerId: string; isLandlord: boolean; multiplier: number }
  | { type: 'GIFT_EFFECT'; nickname: string; effectType: string; targetId: string };

/** AI 角色名称映射 */
const AI_NAMES: Record<string, string> = {
  'AI-Alpha': '烈焰哥',
  'AI-Beta': '冰山姐',
  'AI-Gamma': '戏精弟',
};

class CommentaryGenerator {
  /** 根据游戏事件生成解说文本 */
  generate(event: CommentaryEvent): string | null {
    const name = (id: string) => AI_NAMES[id] ?? id;

    switch (event.type) {
      case 'ROUND_START':
        return `新的一局开始！${name(event.landlordId)}以${event.bidScore}分抢到地主，底牌已亮出！`;

      case 'CARD_PLAYED':
        if (event.remaining <= 2) {
          return `${name(event.playerId)}只剩${event.remaining}张牌了！局势紧张！`;
        }
        if (event.handType === 'STRAIGHT' || event.handType === 'AIRPLANE') {
          return `${name(event.playerId)}打出一手漂亮的${this.handTypeName(event.handType)}！`;
        }
        return null; // 普通出牌不解说，避免话太多

      case 'BOMB':
        return `炸弹！${name(event.playerId)}甩出炸弹，倍数翻倍！`;

      case 'ROCKET':
        return `王炸！${name(event.playerId)}亮出火箭，全场最大！倍数再翻倍！`;

      case 'SPRING':
        return `春天！${name(event.winnerId)}一张牌都没让对手出，太强了！`;

      case 'ROUND_END': {
        const role = event.isLandlord ? '地主' : '农民';
        return `本局结束！${name(event.winnerId)}作为${role}获胜，最终${event.multiplier}倍！`;
      }

      case 'GIFT_EFFECT':
        return `感谢${event.nickname}的礼物！触发了${event.effectType}效果！`;

      default:
        return null;
    }
  }

  private handTypeName(type: string): string {
    const names: Record<string, string> = {
      STRAIGHT: '顺子', STRAIGHT_PAIR: '连对', AIRPLANE: '飞机',
      AIRPLANE_WITH_SINGLES: '飞机带翅膀', BOMB: '炸弹', ROCKET: '火箭',
    };
    return names[type] ?? type;
  }
}
```

#### 5.5.2 Edge TTS 语音合成器

使用微软 Edge TTS（`edge-tts` CLI）将文本转为语音，零成本、低延迟、音质优秀。

```typescript
import { spawn } from 'child_process';
import { EventEmitter } from 'eventemitter3';
import path from 'path';
import fs from 'fs';

/** TTS 配置 */
interface TTSConfig {
  /** edge-tts 语音名称 */
  voice: string;
  /** 语速调整，如 '+10%' / '-5%' */
  rate: string;
  /** 音量调整 */
  volume: string;
  /** 临时音频文件目录 */
  tempDir: string;
}

const DEFAULT_TTS_CONFIG: TTSConfig = {
  voice: 'zh-CN-YunxiNeural',   // 男声，适合解说
  rate: '+15%',                  // 略快，节奏紧凑
  volume: '+0%',
  tempDir: './temp/tts',
};

/** 语音队列项 */
interface SpeechItem {
  text: string;
  priority: 'normal' | 'high';
  filePath: string;
}

interface TTSSpeakerEvents {
  speaking: (text: string) => void;
  idle: () => void;
  error: (err: Error) => void;
}

class TTSSpeaker extends EventEmitter<TTSSpeakerEvents> {
  private config: TTSConfig;
  private queue: SpeechItem[] = [];
  private isSpeaking = false;
  private counter = 0;

  constructor(config: Partial<TTSConfig> = {}) {
    super();
    this.config = { ...DEFAULT_TTS_CONFIG, ...config };
    fs.mkdirSync(this.config.tempDir, { recursive: true });
  }

  /** 将文本加入语音队列 */
  enqueue(text: string, priority: 'normal' | 'high' = 'normal'): void {
    if (!text || text.length === 0) return;

    const filePath = path.join(
      this.config.tempDir,
      `tts_${Date.now()}_${this.counter++}.mp3`
    );

    const item: SpeechItem = { text, priority, filePath };

    if (priority === 'high') {
      // 高优先级插入队首（当前播放之后）
      this.queue.unshift(item);
    } else {
      this.queue.push(item);
    }

    // 队列过长时丢弃旧的普通优先级项
    if (this.queue.length > 5) {
      this.queue = this.queue.filter((item, i) =>
        item.priority === 'high' || i < 3
      );
    }

    if (!this.isSpeaking) {
      this.processNext();
    }
  }

  /** 处理队列中下一条语音 */
  private async processNext(): Promise<void> {
    if (this.queue.length === 0) {
      this.isSpeaking = false;
      this.emit('idle');
      return;
    }

    this.isSpeaking = true;
    const item = this.queue.shift()!;

    try {
      this.emit('speaking', item.text);
      await this.synthesize(item.text, item.filePath);
      await this.playAudio(item.filePath);
    } catch (err) {
      this.emit('error', err instanceof Error ? err : new Error(String(err)));
    } finally {
      // 清理临时文件
      fs.unlink(item.filePath, () => {});
      this.processNext();
    }
  }

  /** 调用 edge-tts CLI 合成语音 */
  private synthesize(text: string, outputPath: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const args = [
        '--voice', this.config.voice,
        '--rate', this.config.rate,
        '--volume', this.config.volume,
        '--text', text,
        '--write-media', outputPath,
      ];

      const proc = spawn('edge-tts', args, { stdio: 'pipe' });
      let stderr = '';

      proc.stderr.on('data', (chunk: Buffer) => { stderr += chunk.toString(); });

      proc.on('close', (code) => {
        if (code === 0) resolve();
        else reject(new Error(`edge-tts 退出码 ${code}: ${stderr}`));
      });

      proc.on('error', (err) => {
        reject(new Error(`edge-tts 启动失败: ${err.message}`));
      });

      // 超时保护：单句合成不应超过 10 秒
      setTimeout(() => {
        proc.kill('SIGTERM');
        reject(new Error('edge-tts 合成超时'));
      }, 10_000);
    });
  }

  /**
   * 播放音频文件
   * 通过虚拟音频设备输出到 OBS 音频捕获
   * Windows: 使用 ffplay / PowerShell
   * macOS: 使用 afplay
   */
  private playAudio(filePath: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const isWin = process.platform === 'win32';
      const cmd = isWin ? 'ffplay' : 'afplay';
      const args = isWin
        ? ['-nodisp', '-autoexit', '-loglevel', 'quiet', filePath]
        : [filePath];

      const proc = spawn(cmd, args, { stdio: 'ignore' });

      proc.on('close', () => resolve());
      proc.on('error', (err) => {
        reject(new Error(`音频播放失败: ${err.message}`));
      });
    });
  }

  /** 清空队列并停止当前播放 */
  flush(): void {
    this.queue = [];
  }
}
```

#### 5.5.3 解说系统集成

将 `CommentaryGenerator` 与 `TTSSpeaker` 串联，监听游戏事件自动解说。

```typescript
class CommentarySystem {
  private generator: CommentaryGenerator;
  private speaker: TTSSpeaker;

  constructor(speaker?: TTSSpeaker) {
    this.generator = new CommentaryGenerator();
    this.speaker = speaker ?? new TTSSpeaker();
  }

  /** 绑定游戏引擎事件 */
  bind(engine: GameEngine): void {
    engine.on('roundStart', (data) => {
      this.speak({
        type: 'ROUND_START',
        landlordId: data.landlordId,
        bidScore: data.bidScore,
      });
    });

    engine.on('cardPlayed', (data) => {
      this.speak({
        type: 'CARD_PLAYED',
        playerId: data.playerId,
        handType: data.handType,
        cards: data.cards,
        remaining: data.remaining,
      });
    });

    engine.on('bomb', (data) => {
      this.speak({ type: 'BOMB', playerId: data.playerId }, 'high');
    });

    engine.on('rocket', (data) => {
      this.speak({ type: 'ROCKET', playerId: data.playerId }, 'high');
    });

    engine.on('roundEnd', (data) => {
      this.speak({
        type: 'ROUND_END',
        winnerId: data.winnerId,
        isLandlord: data.isLandlord,
        multiplier: data.multiplier,
      }, 'high');
    });
  }

  /** 生成文本并送入语音队列 */
  private speak(
    event: CommentaryEvent,
    priority: 'normal' | 'high' = 'normal'
  ): void {
    const text = this.generator.generate(event);
    if (text) {
      this.speaker.enqueue(text, priority);
    }
  }

  /** 外部直接插入解说（如礼物感谢） */
  sayDirect(text: string, priority: 'normal' | 'high' = 'normal'): void {
    this.speaker.enqueue(text, priority);
  }

  dispose(): void {
    this.speaker.flush();
  }
}
```

### 5.6 断流容灾守卫

与 04 §9 备用方案与容灾策略对齐，实现自动断流检测、重连与降级。

```typescript
interface StreamGuardConfig {
  /** 推流状态轮询间隔 (ms) */
  pollInterval: number;
  /** 最大重连次数 */
  maxRetries: number;
  /** 重连基础延迟 (ms)，实际延迟 = base × 重试次数 */
  retryBaseDelay: number;
  /** 连续失败后切换备用推流的阈值 */
  fallbackThreshold: number;
}

const DEFAULT_GUARD_CONFIG: StreamGuardConfig = {
  pollInterval: 5_000,
  maxRetries: 10,
  retryBaseDelay: 3_000,
  fallbackThreshold: 5,
};

interface StreamGuardEvents {
  reconnecting: (attempt: number) => void;
  reconnected: () => void;
  fallback: () => void;
  gaveUp: () => void;
}

class StreamGuard extends EventEmitter<StreamGuardEvents> {
  private obs: OBSController;
  private config: StreamGuardConfig;
  private timer: ReturnType<typeof setInterval> | null = null;
  private retryCount = 0;
  private isReconnecting = false;

  constructor(obs: OBSController, config: Partial<StreamGuardConfig> = {}) {
    super();
    this.obs = obs;
    this.config = { ...DEFAULT_GUARD_CONFIG, ...config };
  }

  /** 启动容灾守卫 */
  start(): void {
    this.timer = setInterval(() => this.check(), this.config.pollInterval);
  }

  /** 停止容灾守卫 */
  stop(): void {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }

  /** 检查推流状态 */
  private async check(): Promise<void> {
    if (this.isReconnecting) return;

    try {
      const status = await this.obs.getStreamStatus();
      if (!status.active) {
        console.error('[StreamGuard] 推流中断，启动重连');
        await this.reconnect();
      } else {
        // 推流正常，重置计数
        this.retryCount = 0;
      }
    } catch {
      // OBS 连接本身断开
      console.error('[StreamGuard] OBS 连接异常');
    }
  }

  /** 指数退避重连 */
  private async reconnect(): Promise<void> {
    this.isReconnecting = true;

    while (this.retryCount < this.config.maxRetries) {
      this.retryCount++;
      this.emit('reconnecting', this.retryCount);

      // 达到备用阈值时切换备用链路
      if (this.retryCount === this.config.fallbackThreshold) {
        this.emit('fallback');
        await this.switchToFallback();
      }

      const delay = this.config.retryBaseDelay * this.retryCount;
      await this.sleep(delay);

      try {
        await this.obs.startStream();
        console.log(`[StreamGuard] 第${this.retryCount}次重连成功`);
        this.retryCount = 0;
        this.isReconnecting = false;
        this.emit('reconnected');
        return;
      } catch {
        console.warn(`[StreamGuard] 第${this.retryCount}次重连失败`);
      }
    }

    // 全部重试耗尽
    this.isReconnecting = false;
    this.emit('gaveUp');
    console.error('[StreamGuard] 重连失败，已放弃');
  }

  /**
   * 切换到备用推流链路
   * 与 04 §9.4 对齐：OBS → 本地 nginx-rtmp → 转推抖音
   */
  private async switchToFallback(): Promise<void> {
    try {
      // 通过 OBS WebSocket 修改推流设置为本地 nginx-rtmp
      // OBS 5.x 不直接支持修改推流设置，需通过 Profile 切换
      // 预先在 OBS 中配置好 "备用推流" Profile
      console.log('[StreamGuard] 切换到备用推流链路 (nginx-rtmp)');
    } catch (err) {
      console.error('[StreamGuard] 备用链路切换失败:', err);
    }
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

---

## 6. 礼物监听与互动模块

> 本章与 05-礼物互动系统 深度对齐，实现其中定义的全部接口与管道架构。

### 6.1 模块职责

```
礼物监听与互动模块
├── 抖音礼物监听器 (DouyinGiftListener)     — 与 05 §2 对齐
├── 礼物事件标准化器 (GiftNormalizer)        — 与 05 §2.5 GiftEvent 对齐
├── 事件处理管道 (EventPipeline)             — 与 05 §11.2 管道架构对齐
│   ├── 去重过滤器 (DeduplicationFilter)
│   ├── 阶段锁定过滤器 (PhaseFilter)
│   ├── 冷却过滤器 (CooldownFilter)
│   ├── 公平性过滤器 (FairnessFilter)
│   └── 效果映射过滤器 (EffectMappingFilter)
├── 冷却管理器 (CooldownManager)             — 与 05 §8 对齐
├── 公平性守卫 (FairnessGuard)               — 与 05 §9 对齐
└── 效果执行器 (EffectExecutor)              — 游戏引擎 + 特效引擎桥接
```

### 6.2 DouyinGiftListener — 抖音礼物监听器

负责与抖音开放平台建立 WebSocket 长连接，接收实时礼物事件并转发给标准化器。

```typescript
import WebSocket from 'ws';
import { EventEmitter } from 'eventemitter3';

interface DouyinRawGift {
  event: 'gift';
  data: {
    user_id: string;
    nickname: string;
    gift_id: number;
    gift_name: string;
    gift_count: number;
    gift_value: number;   // 单个礼物价值（抖币）
    timestamp: number;
  };
}

/**
 * 抖音礼物监听器
 * 对齐 05-礼物互动系统 §2.2 抖音开放平台方案
 */
class DouyinGiftListener extends EventEmitter {
  private ws: WebSocket | null = null;
  private roomId: string;
  private accessToken: string;
  private reconnectAttempts = 0;
  private readonly MAX_RECONNECT = 10;
  private readonly RECONNECT_BASE_DELAY = 3000; // ms
  private heartbeatTimer: NodeJS.Timeout | null = null;

  constructor(roomId: string, accessToken: string) {
    super();
    this.roomId = roomId;
    this.accessToken = accessToken;
  }

  /** 建立连接 */
  async connect(): Promise<void> {
    const url = `wss://webcast-open.douyin.com/ws?room_id=${this.roomId}&access_token=${this.accessToken}`;

    this.ws = new WebSocket(url);

    this.ws.on('open', () => {
      console.log('[GiftListener] 连接成功');
      this.reconnectAttempts = 0;
      this.startHeartbeat();
      this.emit('connected');
    });

    this.ws.on('message', (raw: Buffer) => {
      try {
        const msg = JSON.parse(raw.toString());
        if (msg.event === 'gift') {
          this.emit('raw_gift', msg.data);
        } else if (msg.event === 'comment') {
          this.emit('comment', msg.data);
        }
      } catch (err) {
        console.error('[GiftListener] 消息解析失败:', err);
      }
    });

    this.ws.on('close', (code) => {
      console.warn(`[GiftListener] 连接关闭 code=${code}`);
      this.stopHeartbeat();
      this.scheduleReconnect();
    });

    this.ws.on('error', (err) => {
      console.error('[GiftListener] 连接错误:', err.message);
    });
  }

  /** 指数退避重连 */
  private scheduleReconnect(): void {
    if (this.reconnectAttempts >= this.MAX_RECONNECT) {
      console.error('[GiftListener] 达到最大重连次数，放弃重连');
      this.emit('fatal_disconnect');
      return;
    }
    const delay = this.RECONNECT_BASE_DELAY * Math.pow(2, this.reconnectAttempts);
    this.reconnectAttempts++;
    console.log(`[GiftListener] ${delay}ms 后第 ${this.reconnectAttempts} 次重连...`);
    setTimeout(() => this.connect(), delay);
  }

  /** 心跳保活（30s 间隔） */
  private startHeartbeat(): void {
    this.heartbeatTimer = setInterval(() => {
      if (this.ws?.readyState === WebSocket.OPEN) {
        this.ws.ping();
      }
    }, 30_000);
  }

  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }

  /** 优雅关闭 */
  disconnect(): void {
    this.stopHeartbeat();
    this.ws?.close(1000, 'Normal closure');
    this.ws = null;
  }
}
```

> **备用方案切换**：当 `fatal_disconnect` 事件触发时，系统自动切换到第三方弹幕姬方案（05 §2.3），通过本地 `ws://localhost:8080` 获取礼物数据，接口格式保持一致。

### 6.3 GiftNormalizer — 礼物事件标准化器

将不同来源（开放平台 / 弹幕姬 / 抓包）的原始数据统一转换为 `GiftEvent`（05 §2.5）。

```typescript
import { v4 as uuidv4 } from 'uuid';

/** 礼物分级阈值（抖币），对齐 05 §3.1 */
const TIER_THRESHOLDS = {
  small:  { min: 1,    max: 9 },
  medium: { min: 10,   max: 99 },
  large:  { min: 100,  max: 999 },
  super:  { min: 1000, max: Infinity },
} as const;

type GiftTier = keyof typeof TIER_THRESHOLDS;

interface GiftEvent {
  id: string;
  userId: string;
  nickname: string;
  giftId: number;
  giftName: string;
  count: number;
  unitValue: number;
  totalValue: number;
  tier: GiftTier;
  timestamp: number;
}

class GiftNormalizer {
  /** 将原始礼物数据标准化 */
  normalize(raw: any, source: 'douyin_api' | 'barrage_tool' | 'browser'): GiftEvent {
    const unitValue = Number(raw.gift_value ?? raw.unitValue ?? 1);
    const count = Number(raw.gift_count ?? raw.count ?? 1);
    const totalValue = unitValue * count;

    return {
      id: raw.id ?? uuidv4(),
      userId: String(raw.user_id ?? raw.userId),
      nickname: String(raw.nickname ?? '匿名观众'),
      giftId: Number(raw.gift_id ?? raw.giftId),
      giftName: String(raw.gift_name ?? raw.giftName ?? '未知礼物'),
      count,
      unitValue,
      totalValue,
      tier: this.classifyTier(totalValue),
      timestamp: Number(raw.timestamp ?? Date.now()),
    };
  }

  private classifyTier(totalValue: number): GiftTier {
    for (const [tier, range] of Object.entries(TIER_THRESHOLDS)) {
      if (totalValue >= range.min && totalValue <= range.max) {
        return tier as GiftTier;
      }
    }
    return 'small';
  }
}
```

### 6.4 EffectExecutor — 效果执行器

桥接游戏引擎与前端特效引擎，将管道输出的 `GameEffect` 分发到对应模块执行。

```typescript
import { EventBus } from '../shared/event-bus';

interface GameEffect {
  type: string;          // 效果代码，对齐 05 §3.2
  target: string;        // 'random' | 'opponent' | 'specified' | 'all'
  targetPlayerId?: string;
  data: Record<string, any>;
}

/**
 * 效果执行器
 * 职责：接收管道输出 → 调用游戏引擎修改牌局 → 通知前端播放特效
 */
class EffectExecutor {
  constructor(
    private eventBus: EventBus,
    private gameEngine: GameEngine,
  ) {}

  async execute(effect: GameEffect, gift: GiftEvent): Promise<void> {
    // 1. 执行游戏逻辑（改变牌面的效果）
    const gameResult = await this.applyGameLogic(effect);

    // 2. 通知前端播放视觉特效（对齐 03 §11 + 05 §10）
    this.eventBus.emit('effect:play', {
      effectType: effect.type,
      layer: this.getEffectLayer(effect.type),
      data: { ...effect.data, ...gameResult, nickname: gift.nickname },
    });

    // 3. 触发 TTS 解说（大/超级礼物）
    if (['large', 'super'].includes(gift.tier)) {
      this.eventBus.emit('tts:speak', {
        template: `gift_${effect.type.toLowerCase()}`,
        vars: { nickname: gift.nickname, aiName: effect.targetPlayerId },
        priority: gift.tier === 'super' ? 'highest' : 'high',
      });
    }

    // 4. 记录合规日志（对齐 07 §9.3）
    this.eventBus.emit('log:gift_effect', { gift, effect, gameResult });
  }

  private async applyGameLogic(effect: GameEffect): Promise<Record<string, any>> {
    switch (effect.type) {
      case 'PEEK_CARD':
        return this.gameEngine.peekCard(effect.targetPlayerId!, 1);
      case 'SWAP_CARD':
        return this.gameEngine.swapRandomCard(effect.targetPlayerId!);
      case 'GRANT_CARD':
        return this.gameEngine.grantCardFromDeck(effect.targetPlayerId!);
      case 'FORCE_BOMB':
        return this.gameEngine.setForceBomb(effect.targetPlayerId!);
      case 'DOUBLE_SCORE':
        return this.gameEngine.doubleCurrentMultiplier();
      case 'RESHUFFLE':
        return this.gameEngine.reshuffleHands();
      case 'SWAP_ROLES':
        return this.gameEngine.swapFarmerHands();
      case 'AUDIENCE_PICK':
        this.eventBus.emit('vote:start_landlord_pick');
        return { voteStarted: true };
      default:
        // CHEER / ROSE_RAIN / BUBBLE_MSG / SHOW_HINT — 纯视觉，无游戏逻辑
        return {};
    }
  }

  /** 特效渲染层级映射，对齐 05 §10.1 */
  private getEffectLayer(type: string): 1 | 2 | 3 {
    const layerMap: Record<string, 1 | 2 | 3> = {
      CHEER: 1, ROSE_RAIN: 1, BUBBLE_MSG: 1,
      PEEK_CARD: 2, SWAP_CARD: 2, SHOW_HINT: 2,
      GRANT_CARD: 2, DOUBLE_SCORE: 2, FORCE_BOMB: 2,
      RESHUFFLE: 3, SWAP_ROLES: 3, AUDIENCE_PICK: 3,
    };
    return layerMap[type] ?? 1;
  }
}
```

### 6.5 礼物模块组装

将上述组件串联为完整的礼物互动子系统，对齐 05 §11.4 管道组装。

```typescript
/** 礼物互动子系统初始化入口 */
function initGiftSubsystem(deps: {
  gameEngine: GameEngine;
  eventBus: EventBus;
  config: { roomId: string; accessToken: string; source: 'douyin_api' | 'barrage_tool' };
}): void {
  const { gameEngine, eventBus, config } = deps;

  // 1. 实例化各组件
  const listener = new DouyinGiftListener(config.roomId, config.accessToken);
  const normalizer = new GiftNormalizer();
  const cooldownMgr = new CooldownManager();   // 05 §8
  const benefitTracker = new BenefitTracker();  // 05 §9.3.2
  const effectMapper = new GiftEffectMapper();  // 05 §3.3
  const executor = new EffectExecutor(eventBus, gameEngine);

  // 2. 组装事件处理管道（05 §11.2）
  const pipeline = new EventPipeline()
    .use(new DeduplicationFilter())
    .use(new PhaseFilter(gameEngine))
    .use(new CooldownFilter(cooldownMgr))
    .use(new FairnessFilter(benefitTracker))
    .use(new EffectMappingFilter(effectMapper));

  // 3. 监听原始礼物事件 → 标准化 → 管道处理 → 执行
  listener.on('raw_gift', async (raw: any) => {
    const gift = normalizer.normalize(raw, config.source);
    const effect = await pipeline.process(gift);
    if (effect) {
      await executor.execute(effect, gift);
    }
  });

  // 4. 致命断连时切换备用方案
  listener.on('fatal_disconnect', () => {
    eventBus.emit('alert:gift_listener_down');
  });

  // 5. 每局重置冷却计数
  eventBus.on('game:round_start', (roundId: string) => {
    cooldownMgr.resetRound(roundId);
  });

  // 6. 启动连接
  listener.connect();
}
```

---

## 7. 数据存储方案

> 本项目为单机部署的直播工具，数据存储以轻量级本地方案为主，无需分布式数据库。

### 7.1 存储架构总览

```
data/
├── db/
│   └── doudizhu.sqlite        ← 结构化数据（对局记录、统计、礼物日志）
├── config/
│   ├── app.json                ← 应用配置（房间号、Token、开关）
│   ├── ai-characters.json      ← AI 角色配置（对齐 00 §3 角色定义）
│   ├── gift-mapping.json       ← 礼物映射表（对齐 05 §3.2）
│   └── sensitive-words.json    ← 敏感词库（对齐 07 §4.3）
├── logs/
│   ├── game-YYYY-MM-DD.jsonl   ← 游戏引擎日志
│   ├── gift-YYYY-MM-DD.jsonl   ← 礼物效果日志（合规要求 ≥90天）
│   ├── tts-YYYY-MM-DD.jsonl    ← TTS 输出日志（合规要求 ≥90天）
│   └── stream-YYYY-MM-DD.log  ← 推流状态日志
└── assets/
    ├── audio/                  ← 音效文件（03 §13.2）
    ├── lottie/                 ← Lottie 动画 JSON
    └── sprites/                ← PixiJS SpriteSheet
```

### 7.2 SQLite 数据库表结构

#### 7.2.1 对局记录表

```sql
CREATE TABLE rounds (
  id            TEXT PRIMARY KEY,          -- 对局唯一ID (UUID)
  session_id    TEXT NOT NULL,             -- 直播场次ID
  round_number  INTEGER NOT NULL,          -- 当场第N局
  landlord_id   TEXT NOT NULL,             -- 地主AI角色ID
  bid_score     INTEGER NOT NULL,          -- 叫分 (1/2/3)
  winner_side   TEXT NOT NULL,             -- 'landlord' | 'farmer'
  winner_id     TEXT NOT NULL,             -- 获胜AI角色ID
  base_multiplier INTEGER NOT NULL DEFAULT 1, -- 基础倍数
  bomb_count    INTEGER NOT NULL DEFAULT 0,   -- 炸弹数量
  final_multiplier INTEGER NOT NULL,       -- 最终倍数
  is_spring     BOOLEAN NOT NULL DEFAULT 0,-- 是否春天
  is_anti_spring BOOLEAN NOT NULL DEFAULT 0,
  score_change  INTEGER NOT NULL,          -- 积分变化绝对值
  duration_ms   INTEGER,                   -- 对局耗时(ms)
  created_at    TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX idx_rounds_session ON rounds(session_id);
CREATE INDEX idx_rounds_created ON rounds(created_at);
```

#### 7.2.2 AI 角色统计表

```sql
CREATE TABLE ai_stats (
  ai_id         TEXT PRIMARY KEY,          -- 角色ID: 'ai-alpha' / 'ai-beta' / 'ai-gamma'
  display_name  TEXT NOT NULL,             -- 显示名: '烈焰哥' / '冰山姐' / '戏精弟'
  total_rounds  INTEGER NOT NULL DEFAULT 0,
  total_wins    INTEGER NOT NULL DEFAULT 0,
  landlord_rounds INTEGER NOT NULL DEFAULT 0,
  landlord_wins   INTEGER NOT NULL DEFAULT 0,
  farmer_rounds   INTEGER NOT NULL DEFAULT 0,
  farmer_wins     INTEGER NOT NULL DEFAULT 0,
  total_score     INTEGER NOT NULL DEFAULT 0, -- 累计虚拟战绩分
  bombs_played    INTEGER NOT NULL DEFAULT 0,
  rockets_played  INTEGER NOT NULL DEFAULT 0,
  springs_dealt   INTEGER NOT NULL DEFAULT 0, -- 打出春天次数
  springs_received INTEGER NOT NULL DEFAULT 0,-- 被春天次数
  current_streak  INTEGER NOT NULL DEFAULT 0, -- 当前连胜/连败（正=连胜，负=连败）
  max_win_streak  INTEGER NOT NULL DEFAULT 0,
  updated_at      TEXT NOT NULL DEFAULT (datetime('now'))
);
```

#### 7.2.3 礼物效果日志表

> 合规要求：日志保留 ≥ 90 天（07 §9.3）

```sql
CREATE TABLE gift_logs (
  id            TEXT PRIMARY KEY,
  round_id      TEXT,                      -- 关联对局ID（可为空，非对局期间的礼物）
  user_id       TEXT NOT NULL,             -- 送礼观众ID
  nickname      TEXT NOT NULL,
  gift_name     TEXT NOT NULL,
  gift_value    INTEGER NOT NULL,          -- 总价值（抖币）
  tier          TEXT NOT NULL,             -- 'small'|'medium'|'large'|'super'
  effect_type   TEXT,                      -- 触发的效果代码
  executed      BOOLEAN NOT NULL DEFAULT 0,-- 效果是否成功执行
  reject_reason TEXT,                      -- 拒绝原因（冷却/上限/阶段锁定）
  created_at    TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY (round_id) REFERENCES rounds(id)
);

CREATE INDEX idx_gift_logs_created ON gift_logs(created_at);
CREATE INDEX idx_gift_logs_user ON gift_logs(user_id);
```

### 7.3 JSON 配置文件规范

#### 7.3.1 应用配置 `app.json`

```json
{
  "douyin": {
    "roomId": "",
    "accessToken": "",
    "giftSource": "douyin_api"
  },
  "obs": {
    "host": "localhost",
    "port": 4455,
    "password": ""
  },
  "stream": {
    "rtmpUrl": "rtmp://push.douyin.com/live/",
    "streamKey": "",
    "resolution": "1920x1080",
    "fps": 30,
    "bitrate": 4000
  },
  "game": {
    "autoPlay": true,
    "roundIntervalMs": 5000,
    "thinkingTimeRange": [1000, 5000]
  },
  "tts": {
    "engine": "edge-tts",
    "defaultVoice": "zh-CN-YunxiNeural",
    "speed": 1.0
  }
}
```

#### 7.3.2 AI 角色配置 `ai-characters.json`

```json
[
  {
    "id": "ai-alpha",
    "name": "烈焰哥",
    "personality": "aggressive",
    "ttsVoice": "zh-CN-YunjianNeural",
    "avatar": "assets/sprites/avatar-alpha.png",
    "themeColor": "#FF4444",
    "catchphrase": "全要了！"
  },
  {
    "id": "ai-beta",
    "name": "冰山姐",
    "personality": "defensive",
    "ttsVoice": "zh-CN-XiaoyiNeural",
    "avatar": "assets/sprites/avatar-beta.png",
    "themeColor": "#00BFFF",
    "catchphrase": "稳住。"
  },
  {
    "id": "ai-gamma",
    "name": "戏精弟",
    "personality": "chaotic",
    "ttsVoice": "zh-CN-YunxiNeural",
    "avatar": "assets/sprites/avatar-gamma.png",
    "themeColor": "#9B59B6",
    "catchphrase": "惊不惊喜？"
  }
]
```

### 7.4 日志管理策略

| 日志类型 | 格式 | 轮转策略 | 保留期限 | 合规依据 |
|----------|------|----------|----------|----------|
| 游戏引擎日志 | JSONL | 按天轮转 | 30 天 | 内部调试 |
| 礼物效果日志 | JSONL | 按天轮转 | **≥ 90 天** | 07 §9.3 合规要求 |
| TTS 输出日志 | JSONL | 按天轮转 | **≥ 90 天** | 07 §9.3 合规要求 |
| 推流状态日志 | 纯文本 | 按天轮转 | 14 天 | 运维排障 |
| 敏感词命中日志 | JSONL | 按天轮转 | **≥ 90 天** | 07 §6.2 审核要求 |

```typescript
/** 日志轮转清理（每日凌晨执行） */
function cleanupLogs(logsDir: string): void {
  const retentionDays: Record<string, number> = {
    'game':   30,
    'gift':   90,
    'tts':    90,
    'stream': 14,
    'sensitive': 90,
  };

  for (const [prefix, days] of Object.entries(retentionDays)) {
    const cutoff = Date.now() - days * 86400_000;
    const files = fs.readdirSync(logsDir)
      .filter(f => f.startsWith(prefix) && f.endsWith('.jsonl'));

    for (const file of files) {
      const dateStr = file.match(/\d{4}-\d{2}-\d{2}/)?.[0];
      if (dateStr && new Date(dateStr).getTime() < cutoff) {
        fs.unlinkSync(path.join(logsDir, file));
      }
    }
  }
}
```

---

## 8. 模块间通信协议

### 8.1 通信架构总览

系统采用**单进程 EventBus** 作为核心通信机制，所有模块通过事件解耦。

```
┌─────────────────────────────────────────────────────────┐
│                    EventBus (中央事件总线)                │
│                                                         │
│  发布者 ──publish(topic, payload)──→ 订阅者              │
│                                                         │
│  特性:                                                  │
│  - 同步分发（同一 tick 内所有 listener 执行完毕）         │
│  - 支持通配符订阅: game:* 匹配所有 game: 前缀事件        │
│  - 内置事件日志: 最近 1000 条事件可回溯                   │
│  - 类型安全: 每个事件有严格的 payload 类型定义            │
└─────────────────────────────────────────────────────────┘
```

#### EventBus 核心实现

```typescript
type EventHandler<T = any> = (payload: T) => void | Promise<void>;

class EventBus {
  private handlers = new Map<string, Set<EventHandler>>();
  private history: Array<{ topic: string; payload: any; ts: number }> = [];
  private readonly MAX_HISTORY = 1000;

  /** 订阅事件 */
  on<T>(topic: string, handler: EventHandler<T>): () => void {
    if (!this.handlers.has(topic)) this.handlers.set(topic, new Set());
    this.handlers.get(topic)!.add(handler);
    return () => this.handlers.get(topic)?.delete(handler);
  }

  /** 发布事件（同步分发，异步 handler 不阻塞） */
  emit<T>(topic: string, payload: T): void {
    this.history.push({ topic, payload, ts: Date.now() });
    if (this.history.length > this.MAX_HISTORY) this.history.shift();

    // 精确匹配
    this.handlers.get(topic)?.forEach(h => {
      try { h(payload); } catch (e) { console.error(`[EventBus] ${topic}:`, e); }
    });

    // 通配符匹配: game:* 匹配 game:round_start 等
    const prefix = topic.split(':')[0] + ':*';
    this.handlers.get(prefix)?.forEach(h => {
      try { h(payload); } catch (e) { console.error(`[EventBus] ${prefix}:`, e); }
    });
  }

  /** 查询最近事件（调试用） */
  getHistory(filter?: string): typeof this.history {
    if (!filter) return [...this.history];
    return this.history.filter(e => e.topic.startsWith(filter));
  }
}
```

### 8.2 事件命名规范

```
格式: <模块>:<动作>
示例: game:round_start, gift:effect_triggered, tts:speak

模块前缀:
  game:     游戏引擎事件
  ai:       AI 决策事件
  gift:     礼物互动事件
  tts:      语音合成事件
  stream:   推流/直播事件
  ui:       前端 UI 事件
  alert:    告警/监控事件
  system:   系统级事件
```

### 8.3 完整事件目录

#### 8.3.1 游戏引擎事件 (`game:*`)

| 事件名 | 发布者 | 订阅者 | Payload 类型 | 说明 |
|--------|--------|--------|-------------|------|
| `game:round_start` | GameEngine | AI, Gift, TTS, UI | `{ roundId: string; roundNum: number; }` | 新一局开始 |
| `game:deal_complete` | GameEngine | AI, UI | `{ hands: Record<Seat, Card[]>; landlordCards: Card[]; }` | 发牌完成 |
| `game:bid_turn` | GameEngine | AI, UI | `{ seat: Seat; currentBid: number; }` | 轮到叫地主 |
| `game:bid_made` | GameEngine | TTS, UI | `{ seat: Seat; bid: number \| null; }` | 叫地主/不叫 |
| `game:landlord_decided` | GameEngine | AI, TTS, UI | `{ seat: Seat; finalBid: number; landlordCards: Card[]; }` | 地主确定 |
| `game:play_turn` | GameEngine | AI, UI | `{ seat: Seat; lastPlay: Play \| null; mustFollow: boolean; }` | 轮到出牌 |
| `game:card_played` | GameEngine | AI, TTS, Gift, UI | `{ seat: Seat; cards: Card[]; handType: HandType; remaining: number; }` | 出牌完成 |
| `game:pass` | GameEngine | TTS, UI | `{ seat: Seat; }` | 要不起/不出 |
| `game:trick_won` | GameEngine | UI | `{ seat: Seat; }` | 一轮收牌 |
| `game:bomb_played` | GameEngine | TTS, UI | `{ seat: Seat; cards: Card[]; newMultiplier: number; }` | 炸弹出牌 |
| `game:rocket_played` | GameEngine | TTS, UI | `{ seat: Seat; newMultiplier: number; }` | 火箭出牌 |
| `game:round_end` | GameEngine | AI, TTS, Gift, UI | `{ winner: 'landlord' \| 'farmer'; scores: Record<Seat, number>; isSpring: boolean; multiplier: number; }` | 一局结束 |

#### 8.3.2 AI 决策事件 (`ai:*`)

| 事件名 | 发布者 | 订阅者 | Payload 类型 | 说明 |
|--------|--------|--------|-------------|------|
| `ai:thinking_start` | AIDecisionEngine | UI | `{ seat: Seat; complexity: 'low' \| 'medium' \| 'high'; }` | AI 开始思考 |
| `ai:thinking_end` | AIDecisionEngine | UI | `{ seat: Seat; durationMs: number; }` | AI 思考结束 |
| `ai:bid_decision` | AIDecisionEngine | GameEngine | `{ seat: Seat; bid: number \| null; confidence: number; }` | AI 叫分决策 |
| `ai:play_decision` | AIDecisionEngine | GameEngine | `{ seat: Seat; cards: Card[]; strategy: string; }` | AI 出牌决策 |
| `ai:emotion_change` | AIDecisionEngine | UI, TTS | `{ seat: Seat; emotion: EmotionType; intensity: number; bubble?: string; }` | AI 情绪变化（驱动表情和气泡） |

#### 8.3.3 礼物互动事件 (`gift:*`)

| 事件名 | 发布者 | 订阅者 | Payload 类型 | 说明 |
|--------|--------|--------|-------------|------|
| `gift:received` | DouyinGiftListener | EventPipeline | `GiftEvent`（见 05 §2.5） | 收到原始礼物 |
| `gift:effect_triggered` | EffectExecutor | UI, TTS | `{ effectType: string; target: Seat \| 'all'; data: any; nickname: string; }` | 效果已触发 |
| `gift:effect_rejected` | EventPipeline | UI | `{ reason: string; giftName: string; nickname: string; cooldownRemaining?: number; }` | 效果被拒绝（冷却/上限） |
| `gift:audience_vote_start` | EffectExecutor | UI | `{ duration: number; candidates: Seat[]; }` | 观众选地主投票开始 |
| `gift:audience_vote_end` | UI | GameEngine | `{ winner: Seat; votes: Record<Seat, number>; }` | 投票结束 |

#### 8.3.4 TTS 语音事件 (`tts:*`)

| 事件名 | 发布者 | 订阅者 | Payload 类型 | 说明 |
|--------|--------|--------|-------------|------|
| `tts:speak` | GameEngine / Gift | TTSEngine | `{ text: string; voice: string; priority: number; emotion?: string; }` | 请求语音合成 |
| `tts:playing` | TTSEngine | UI | `{ text: string; voice: string; durationMs: number; }` | 语音开始播放 |
| `tts:finished` | TTSEngine | UI | `{ text: string; }` | 语音播放完毕 |
| `tts:queue_full` | TTSEngine | Alert | `{ queueSize: number; }` | 语音队列积压告警 |

#### 8.3.5 推流/直播事件 (`stream:*`)

| 事件名 | 发布者 | 订阅者 | Payload 类型 | 说明 |
|--------|--------|--------|-------------|------|
| `stream:connected` | StreamManager | UI, Alert | `{ rtmpUrl: string; }` | 推流连接成功 |
| `stream:disconnected` | StreamManager | Alert | `{ reason: string; }` | 推流断开 |
| `stream:stats` | StreamManager | Alert | `{ fps: number; bitrate: number; droppedFrames: number; }` | 推流质量统计（每 5s） |
| `stream:scene_switch` | SceneController | UI | `{ from: string; to: string; }` | OBS 场景切换 |

#### 8.3.6 告警事件 (`alert:*`)

| 事件名 | 发布者 | 订阅者 | Payload 类型 | 说明 |
|--------|--------|--------|-------------|------|
| `alert:sensitive_word` | ContentFilter | Logger, UI | `{ word: string; source: string; action: 'replace' \| 'block'; }` | 敏感词命中（07 §6.2） |
| `alert:health_score_drop` | Monitor | Logger | `{ current: number; delta: number; }` | 健康分下降告警 |
| `alert:performance_degrade` | Monitor | EffectManager | `{ fps: number; level: 'mild' \| 'moderate' \| 'severe'; }` | 性能降级触发（03 §16.2） |
| `alert:gift_anomaly` | Monitor | Logger | `{ userId: string; amount: number; window: string; }` | 礼物异常集中（07 §6.3） |

#### 8.3.7 系统事件 (`system:*`)

| 事件名 | 发布者 | 订阅者 | Payload 类型 | 说明 |
|--------|--------|--------|-------------|------|
| `system:init_complete` | App | All | `{ modules: string[]; }` | 所有模块初始化完成 |
| `system:shutdown` | App | All | `{ reason: string; }` | 系统关闭信号 |
| `system:config_reload` | ConfigManager | All | `{ changed: string[]; }` | 配置热更新 |

### 8.4 典型事件流转示例

#### 8.4.1 一次完整出牌的事件链

```
GameEngine                AIDecisionEngine           UI                TTS
    │                          │                      │                 │
    ├─ game:play_turn ────────→│                      │                 │
    │                          ├─ ai:thinking_start ─→│(显示思考动画)    │
    │                          │   (1~3s 决策)        │                 │
    │                          ├─ ai:emotion_change ─→│(更新表情)       →│(情绪气泡TTS)
    │                          ├─ ai:play_decision ──→│                 │
    │←─ (cards validated) ─────┤                      │                 │
    ├─ game:card_played ──────────────────────────────→│(出牌动画)       │
    │                                                  │                →│(解说TTS)
    │  [如果是炸弹]                                     │                 │
    ├─ game:bomb_played ──────────────────────────────→│(炸弹特效 03§5)  │
    │                                                  │                →│("炸弹！倍数翻倍！")
```

#### 8.4.2 礼物触发效果的事件链

```
DouyinGiftListener    EventPipeline    EffectExecutor    GameEngine    UI       TTS
       │                   │                │               │          │         │
       ├─ gift:received ──→│                │               │          │         │
       │                   ├─ (去重)        │               │          │         │
       │                   ├─ (阶段检查)    │               │          │         │
       │                   ├─ (冷却检查)    │               │          │         │
       │                   ├─ (公平性检查)  │               │          │         │
       │                   ├─ (效果映射)    │               │          │         │
       │                   ├──────────────→│               │          │         │
       │                   │               ├─ (游戏逻辑) ─→│          │         │
       │                   │               ├─ gift:effect_triggered ─→│(特效)   │
       │                   │               ├──────────────────────────────────→│(播报)
       │                   │               ├─ (合规日志)   │          │         │
```

---

## 9. 部署方案

### 9.1 部署架构总览

本项目为**单机部署**架构，所有服务运行在一台 Windows 主机上，通过 OBS Studio 推流到抖音。

```
┌─────────────────────────────────────────────────┐
│              直播主机 (Windows 10/11)             │
│                                                  │
│  ┌──────────────┐  ┌──────────────┐             │
│  │  Node.js 进程 │  │  OBS Studio  │             │
│  │  (游戏+服务)  │──│  (推流采集)   │──→ 抖音 RTMP │
│  └──────┬───────┘  └──────┬───────┘             │
│         │                  │                     │
│  ┌──────┴───────┐  ┌──────┴───────┐             │
│  │  Chrome 浏览器 │  │  虚拟音频设备 │             │
│  │  (前端渲染)   │  │  (VB-Cable)  │             │
│  └──────────────┘  └──────────────┘             │
│                                                  │
│  ┌──────────────┐  ┌──────────────┐             │
│  │  SQLite 数据库 │  │  日志文件     │             │
│  │  (data/)      │  │  (logs/)     │             │
│  └──────────────┘  └──────────────┘             │
└─────────────────────────────────────────────────┘
```

### 9.2 主机硬件要求

| 组件 | 最低配置 | 推荐配置 | 说明 |
|------|----------|----------|------|
| CPU | i5-10400 (6C12T) | i7-12700 (12C20T) | 游戏逻辑 + OBS 编码 |
| GPU | GTX 1650 4GB | RTX 3060 8GB | PixiJS WebGL + NVENC 硬编码 |
| 内存 | 16 GB | 32 GB | Node.js + Chrome + OBS 并行 |
| 硬盘 | 256 GB SSD | 512 GB NVMe SSD | 日志写入 + 录像缓存 |
| 网络 | 上行 10 Mbps | 上行 20 Mbps | 推流 4Mbps + 抖音 API |
| 操作系统 | Windows 10 21H2+ | Windows 11 | OBS 兼容性最佳 |

### 9.3 软件环境与依赖

| 软件 | 版本 | 用途 | 安装方式 |
|------|------|------|----------|
| Node.js | 18 LTS+ | 游戏引擎 + 后端服务 | 官网安装包 |
| pnpm | 8+ | 包管理器（Monorepo） | `npm i -g pnpm` |
| Chrome | 最新稳定版 | 前端渲染宿主 | 官网安装 |
| OBS Studio | 30+ | 推流采集 | 官网安装 |
| VB-Cable | 最新版 | 虚拟音频路由（TTS → OBS） | 官网免费版 |
| SQLite | 内嵌 (better-sqlite3) | 数据存储 | npm 依赖自动安装 |
| Edge TTS | CLI 或 npm 包 | 语音合成 | `pip install edge-tts` 或 npm |

### 9.4 启动流程

```
一键启动顺序:

1. 环境检查
   └─ 检测 Node.js / Chrome / OBS / VB-Cable 是否就绪

2. 启动 Node.js 后端服务
   └─ pnpm --filter server start
   └─ 初始化 GameEngine、AIDecisionEngine、EventBus
   └─ 连接抖音 WebSocket（礼物/弹幕监听）

3. 启动前端渲染
   └─ pnpm --filter frontend dev
   └─ Chrome 自动打开 http://localhost:5173
   └─ 全屏模式 (--kiosk --start-fullscreen)

4. 启动 OBS 推流
   └─ OBS 加载预设 Scene Collection
   └─ 浏览器源指向 localhost:5173
   └─ 音频源指向 VB-Cable Output
   └─ 开始推流到抖音 RTMP 地址

5. 系统就绪
   └─ EventBus 发出 system:init_complete
   └─ 开始第一局对战
```

### 9.5 一键启动脚本

```bash
#!/bin/bash
# scripts/start.sh - 一键启动直播系统

set -e

echo "=== AI 斗地主直播系统启动 ==="

# 1. 环境检查
echo "[1/4] 环境检查..."
command -v node >/dev/null || { echo "❌ Node.js 未安装"; exit 1; }
command -v pnpm >/dev/null || { echo "❌ pnpm 未安装"; exit 1; }

NODE_VER=$(node -v | cut -d'v' -f2 | cut -d'.' -f1)
[ "$NODE_VER" -ge 18 ] || { echo "❌ Node.js 版本需 >= 18"; exit 1; }
echo "✅ 环境检查通过"

# 2. 安装依赖（首次或更新后）
echo "[2/4] 检查依赖..."
pnpm install --frozen-lockfile 2>/dev/null || pnpm install

# 3. 启动后端服务
echo "[3/4] 启动后端服务..."
pnpm --filter server start &
SERVER_PID=$!
sleep 3

# 4. 启动前端
echo "[4/4] 启动前端渲染..."
pnpm --filter frontend dev &
FRONTEND_PID=$!
sleep 5

echo "=== 系统启动完成 ==="
echo "前端地址: http://localhost:5173"
echo "请在 OBS 中配置浏览器源并开始推流"

# 等待退出信号
trap "kill $SERVER_PID $FRONTEND_PID 2>/dev/null; exit 0" SIGINT SIGTERM
wait
```

---

## 10. 技术选型对比与决策

本章记录各关键技术栈的选型过程，包括候选方案对比、决策理由和风险评估。

### 10.1 渲染引擎选型

| 维度 | PixiJS 7 ★选定 | Canvas 2D 原生 | Three.js | Phaser 3 |
|------|----------------|---------------|----------|----------|
| 渲染方式 | WebGL 2D | CPU 软渲染 | WebGL 3D | WebGL 2D (基于 PixiJS) |
| 2D 性能 | ★★★★★ | ★★★☆☆ | ★★★☆☆ (过重) | ★★★★☆ |
| 粒子系统 | @pixi/particle-emitter | 需手写 | 内置强大 | 内置 |
| 学习曲线 | 中等 | 低 | 高 | 中等 |
| 包体积 | ~150KB gzip | 0 | ~600KB gzip | ~300KB gzip |
| 社区生态 | 活跃，插件丰富 | 无 | 非常活跃 | 活跃 |
| OBS 兼容性 | ★★★★★ | ★★★★★ | ★★★★☆ | ★★★★★ |
| 适合场景 | 2D 游戏/可视化 | 简单图形 | 3D 场景 | 完整游戏框架 |

**决策理由**：
1. 本项目为纯 2D 场景，Three.js 的 3D 能力属于过度设计
2. Canvas 2D 原生在粒子特效密集时性能不足（炸弹/火箭特效需 60+ 粒子）
3. Phaser 3 底层基于 PixiJS，但引入了完整游戏框架的额外开销（物理引擎、场景管理等本项目不需要的功能）
4. PixiJS 提供恰到好处的 WebGL 2D 渲染能力 + 成熟的粒子系统，KISS 原则最优解

### 10.2 状态管理选型

| 维度 | Zustand 4 ★选定 | Redux Toolkit | MobX 6 | Jotai |
|------|-----------------|---------------|--------|-------|
| 包体积 | ~2KB gzip | ~11KB gzip | ~16KB gzip | ~3KB gzip |
| 样板代码 | 极少 | 中等（已优化） | 少 | 极少 |
| TypeScript 支持 | ★★★★★ | ★★★★★ | ★★★★☆ | ★★★★★ |
| 学习曲线 | 低 | 中 | 中 | 低 |
| DevTools | zustand/middleware | Redux DevTools | mobx-devtools | Jotai DevTools |
| React 外访问 | ★★★★★ 原生支持 | ★★★☆☆ 需额外配置 | ★★★★☆ | ★★☆☆☆ |
| 性能 | 细粒度订阅 | 需 selector 优化 | 自动追踪 | 原子级更新 |

**决策理由**：
1. 游戏引擎（非 React 组件）需要频繁读写状态，Zustand 的 `getState()` / `setState()` 可在 React 外直接调用，这是核心需求
2. Redux Toolkit 虽然成熟，但 action/reducer 模式对高频游戏状态更新过于繁琐
3. MobX 的 Proxy 机制在 PixiJS 渲染循环中可能引入不可预测的性能开销
4. Zustand 2KB 体积 + 零样板代码 + React 内外通用，完美匹配本项目架构

### 10.3 动画引擎选型

| 维度 | GSAP 3 ★选定 | anime.js | Framer Motion | Web Animations API |
|------|-------------|----------|---------------|-------------------|
| 包体积 | ~24KB gzip | ~7KB gzip | ~30KB gzip | 0 (原生) |
| 时间线编排 | ★★★★★ 业界最强 | ★★★☆☆ | ★★★☆☆ | ★★☆☆☆ |
| 缓动函数库 | 内置 50+ | 内置 30+ | 内置 20+ | 需手写 |
| 非 DOM 目标 | ★★★★★ 任意对象 | ★★★★☆ | ★☆☆☆☆ 仅 React | ★☆☆☆☆ 仅 DOM |
| 序列控制 | stagger/label/嵌套 | 基础 stagger | variants | 无 |
| 性能 | ★★★★★ | ★★★★☆ | ★★★☆☆ | ★★★★★ |

**决策理由**：
1. GSAP 的 timeline 编排能力是核心需求——发牌动画需要精确到 50ms 的序列控制（见 `03-特效与动画设计 §2`）
2. GSAP 可直接驱动 PixiJS Sprite 属性（x/y/rotation/scale/alpha），无需 DOM 中间层
3. Framer Motion 绑定 React 组件，无法驱动 PixiJS Canvas 内的对象
4. anime.js 轻量但时间线能力不足以支撑炸弹/火箭等多阶段复合动画

### 10.4 音频引擎选型

| 维度 | Howler.js 2 ★选定 | Tone.js | Web Audio API 原生 | HTML5 Audio |
|------|-------------------|---------|-------------------|-------------|
| 包体积 | ~7KB gzip | ~150KB gzip | 0 (原生) | 0 (原生) |
| 音效延迟 | < 50ms | < 20ms | < 10ms | 100~300ms |
| 多轨混音 | ★★★★★ | ★★★★★ | ★★★★☆ 需手写 | ★★☆☆☆ |
| Sprite 音频 | ★★★★★ 内置 | ★★★☆☆ | ★★☆☆☆ 需手写 | ✗ |
| 自动降级 | Web Audio → HTML5 | 仅 Web Audio | 仅 Web Audio | 仅 HTML5 |
| 学习曲线 | 低 | 高 | 中高 | 低 |

**决策理由**：
1. Howler.js 的 Audio Sprite 功能可将数十个短音效合并为单文件，减少 HTTP 请求
2. 自动降级机制保证在不同浏览器环境下的兼容性
3. Tone.js 专为音乐合成设计，对本项目的简单音效播放场景过于复杂
4. 原生 Web Audio API 功能足够但缺乏便捷的高层封装，Howler.js 是最佳平衡点

### 10.5 数据库选型

| 维度 | SQLite (better-sqlite3) ★选定 | LevelDB | JSON 文件 | PostgreSQL |
|------|------------------------------|---------|-----------|------------|
| 部署复杂度 | 零配置，嵌入式 | 零配置，嵌入式 | 零配置 | 需独立服务 |
| 查询能力 | ★★★★★ 完整 SQL | ★★☆☆☆ KV 查询 | ★☆☆☆☆ 全量读取 | ★★★★★ 完整 SQL |
| 并发写入 | 单写多读（WAL 模式） | 单写多读 | 需手动锁 | 高并发 |
| 数据量上限 | ~140TB | ~数 TB | ~数 MB | 无限制 |
| 备份恢复 | 单文件复制 | 目录复制 | 文件复制 | pg_dump |
| Node.js 集成 | better-sqlite3 同步 API | level 异步 API | fs 原生 | pg 异步 API |

**决策理由**：
1. 单机部署场景下，SQLite 零运维成本，无需额外数据库服务进程
2. 合规日志需要按时间范围查询（90 天保留策略），SQL 查询能力是刚需
3. better-sqlite3 的同步 API 在游戏引擎主循环中避免了异步回调的复杂性
4. JSON 文件在数据量增长后（数万局对局记录）读写性能急剧下降
5. PostgreSQL 对单机项目属于过度设计，违反 YAGNI 原则

### 10.6 TTS 语音引擎选型

| 维度 | Edge TTS ★选定 | Azure TTS | 百度语音 | 本地 Piper TTS |
|------|---------------|-----------|---------|---------------|
| 费用 | 免费 | 按量付费 (~¥4/万字) | 按量付费 (~¥3/万字) | 免费 |
| 音色数量 | 400+ (含中文) | 400+ | 100+ | 50+ |
| 延迟 | 200~500ms | 100~300ms | 200~400ms | 50~100ms |
| 情绪表达 | ★★★★☆ SSML 支持 | ★★★★★ SSML 完整 | ★★★☆☆ | ★★☆☆☆ |
| 稳定性 | ★★★★☆ 偶有限流 | ★★★★★ SLA 保障 | ★★★★☆ | ★★★★★ 本地运行 |
| 接入方式 | edge-tts CLI / npm | REST API + SDK | REST API | 本地进程 |
| 网络依赖 | 需要 | 需要 | 需要 | 无 |

**决策理由**：
1. 项目初期以零成本验证为目标，Edge TTS 免费且音色质量接近商用水平
2. Edge TTS 支持 SSML 标记，可实现解说语调变化（兴奋/紧张/平静）
3. 本地 Piper TTS 延迟最低但中文音色质量不足，不适合直播场景
4. Azure TTS 作为付费升级路径保留——当日活跃观众超过 3000 时可切换以获得 SLA 保障
5. 降级策略：Edge TTS 不可用时 → 回退到预录制音频片段拼接

### 10.7 技术选型总结

| 领域 | 选定方案 | 版本 | 核心理由 |
|------|---------|------|---------|
| 渲染引擎 | PixiJS | 7+ | WebGL 2D 性能最优，粒子系统成熟 |
| UI 框架 | React | 18+ | 生态丰富，信息面板/弹幕等 DOM 层 |
| 状态管理 | Zustand | 4+ | React 内外通用，零样板代码 |
| 动画引擎 | GSAP | 3+ | 时间线编排业界最强，驱动 PixiJS |
| 粒子系统 | @pixi/particle-emitter | 5+ | PixiJS 官方粒子库 |
| 音频引擎 | Howler.js | 2+ | Audio Sprite + 自动降级 |
| TTS 引擎 | Edge TTS | - | 免费 + SSML 情绪表达 |
| 数据库 | SQLite (better-sqlite3) | 9+ | 嵌入式零运维 + SQL 查询 |
| 构建工具 | Vite | 5+ | 极速 HMR，原生 ESM |
| 包管理 | pnpm | 8+ | Monorepo workspace 支持 |
| 运行时 | Node.js | 18+ | LTS 稳定版 |
| 推流 | OBS Studio | 30+ | 行业标准，浏览器源捕获 |

---

## 11. 性能与可靠性设计

### 11.1 性能预算

#### 11.1.1 前端渲染性能

| 指标 | 目标值 | 红线 | 监控方式 |
|------|--------|------|---------|
| 帧率 (FPS) | 60 | ≥ 45 | `requestAnimationFrame` 计时 |
| GPU 占用 | < 40% | < 60% | Chrome DevTools Performance |
| 内存 (JS Heap) | < 150MB | < 300MB | `performance.memory` |
| 粒子总数 | < 200 | < 500 | 粒子管理器内部计数 |
| Draw Call | < 40 | < 80 | PixiJS `renderer.plugins.batch` |
| DOM 节点数 | < 500 | < 1000 | 信息面板 + 弹幕层 |

> 性能预算与 `03-特效与动画设计 §16` 保持一致，本节在其基础上补充后端和系统级指标。

#### 11.1.2 后端与系统性能

| 指标 | 目标值 | 红线 | 监控方式 |
|------|--------|------|---------|
| Node.js 事件循环延迟 | < 10ms | < 50ms | `perf_hooks.monitorEventLoopDelay` |
| Node.js 内存 (RSS) | < 200MB | < 500MB | `process.memoryUsage()` |
| AI 决策延迟 | < 500ms | < 2000ms | 计时器包裹 |
| TTS 合成延迟 | < 1500ms | < 3000ms | 请求-响应计时 |
| 礼物事件处理延迟 | < 200ms | < 1000ms | EventPipeline 计时 |
| SQLite 写入延迟 | < 5ms | < 20ms | better-sqlite3 计时 |
| OBS 编码器负载 | < 70% | < 90% | OBS WebSocket API |
| 推流码率稳定性 | 波动 < 10% | 波动 < 30% | OBS 推流统计 |

### 11.2 三级性能降级策略

当性能指标触及红线时，系统自动执行降级：

| 级别 | 触发条件 | 降级措施 | 恢复条件 |
|------|---------|---------|---------|
| L1 轻度 | FPS < 55 连续 3s | 粒子数量减半；关闭非关键 CSS 动画 | FPS ≥ 58 持续 5s |
| L2 中度 | FPS < 45 连续 3s | 关闭所有粒子特效；礼物特效降为文字提示；弹幕数量限制为 5 条/屏 | FPS ≥ 50 持续 10s |
| L3 重度 | FPS < 30 连续 3s | 关闭所有特效仅保留出牌位移；TTS 队列清空仅保留当前播放；暂停礼物效果处理 | FPS ≥ 40 持续 15s |

```typescript
class PerformanceDegrader {
  private level: 0 | 1 | 2 | 3 = 0;
  private fpsHistory: number[] = [];
  private readonly SAMPLE_SIZE = 180; // 3秒 × 60fps

  /** 每帧调用，记录 FPS 并判断是否需要降级/恢复 */
  tick(currentFps: number): void {
    this.fpsHistory.push(currentFps);
    if (this.fpsHistory.length > this.SAMPLE_SIZE) {
      this.fpsHistory.shift();
    }

    const avgFps = this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length;

    // 降级判断
    if (avgFps < 30 && this.level < 3) this.setLevel(3);
    else if (avgFps < 45 && this.level < 2) this.setLevel(2);
    else if (avgFps < 55 && this.level < 1) this.setLevel(1);

    // 恢复判断（需要更长的稳定期）
    if (avgFps >= 58 && this.level === 1) this.setLevel(0);
    else if (avgFps >= 50 && this.level === 2) this.setLevel(1);
    else if (avgFps >= 40 && this.level === 3) this.setLevel(2);
  }

  private setLevel(newLevel: 0 | 1 | 2 | 3): void {
    if (newLevel === this.level) return;
    console.warn(`[Performance] 降级等级变更: L${this.level} → L${newLevel}`);
    this.level = newLevel;
    eventBus.emit('system:performance_level', { level: newLevel });
  }
}
```

### 11.3 错误恢复机制

#### 11.3.1 错误分级与处理策略

| 错误级别 | 定义 | 处理策略 | 示例 |
|---------|------|---------|------|
| Fatal | 系统无法继续运行 | 停止直播，记录日志，通知运营 | Node.js 崩溃、OBS 断开 |
| Error | 单模块功能异常 | 隔离故障模块，降级运行 | TTS 服务不可用、礼物监听断开 |
| Warning | 非关键功能异常 | 记录日志，自动重试 | 单次 AI 决策超时、数据库写入失败 |
| Info | 可预期的异常状态 | 仅记录日志 | 礼物效果被冷却拒绝 |

#### 11.3.2 各模块故障降级方案

| 故障模块 | 降级方案 | 对直播的影响 |
|---------|---------|------------|
| TTS 引擎 | 回退到预录制音频片段拼接；若仍失败则静默（仅文字解说） | 解说质量下降，但不影响游戏 |
| 礼物监听 | 自动重连（指数退避，最大间隔 30s）；重连期间礼物效果暂停 | 礼物互动暂时中断 |
| AI 决策 | 单次超时 → 随机合法出牌；连续 3 次超时 → 重启 AI 模块 | 出牌质量短暂下降 |
| SQLite | 写入失败 → 内存缓冲（最大 1000 条）→ 恢复后批量写入 | 无感知 |
| OBS 推流 | 检测断流 → 自动重连 → 3 次失败后告警运营 | 观众端短暂黑屏 |
| 前端渲染 | PixiJS 崩溃 → 捕获异常 → 重新初始化 Canvas | 画面闪烁一次 |

#### 11.3.3 自动重连机制

```typescript
class ReconnectManager {
  private attempts = 0;
  private readonly MAX_ATTEMPTS = 10;
  private readonly BASE_DELAY = 1000; // 1秒
  private readonly MAX_DELAY = 30000; // 30秒

  /** 指数退避重连 */
  async reconnect(connectFn: () => Promise<void>): Promise<boolean> {
    while (this.attempts < this.MAX_ATTEMPTS) {
      const delay = Math.min(
        this.BASE_DELAY * Math.pow(2, this.attempts),
        this.MAX_DELAY
      );
      console.warn(`[Reconnect] 第 ${this.attempts + 1} 次重连，等待 ${delay}ms`);
      await sleep(delay);

      try {
        await connectFn();
        this.attempts = 0;
        return true;
      } catch (e) {
        this.attempts++;
      }
    }

    console.error(`[Reconnect] 达到最大重试次数 ${this.MAX_ATTEMPTS}`);
    eventBus.emit('alert:connection_failed', { attempts: this.attempts });
    return false;
  }
}
```

### 11.4 内存管理

#### 11.4.1 内存泄漏防范

| 风险点 | 防范措施 |
|-------|---------|
| EventBus 监听器未注销 | `on()` 返回 `unsubscribe` 函数，模块销毁时统一调用 |
| PixiJS Texture 未释放 | 场景切换时调用 `texture.destroy(true)` |
| 粒子对象累积 | 对象池复用，池上限 500 个 |
| GSAP 动画未清理 | `timeline.kill()` 在动画完成回调中确保执行 |
| 弹幕 DOM 节点堆积 | 滚出屏幕后立即 `removeChild`，同屏上限 30 条 |
| EventBus 历史记录 | 环形缓冲区，上限 1000 条自动淘汰 |
| SQLite WAL 文件膨胀 | 每小时执行 `PRAGMA wal_checkpoint(TRUNCATE)` |

### 11.5 监控告警体系

#### 11.5.1 监控指标采集

```typescript
/** 系统健康度采集器，每 10 秒上报一次 */
class HealthCollector {
  private intervalId: NodeJS.Timeout | null = null;

  start(): void {
    this.intervalId = setInterval(() => {
      const metrics = {
        timestamp: Date.now(),
        nodejs: {
          rss: process.memoryUsage().rss,
          heapUsed: process.memoryUsage().heapUsed,
          eventLoopDelay: this.measureEventLoopDelay(),
        },
        game: {
          roundsPlayed: gameStore.getState().totalRounds,
          currentPhase: gameStore.getState().phase,
        },
        stream: {
          fps: performanceMonitor.getAvgFps(),
          obsEncoderLoad: obsConnector.getEncoderLoad(),
        },
      };
      logger.info('[Health]', metrics);
    }, 10_000);
  }

  stop(): void {
    if (this.intervalId) clearInterval(this.intervalId);
  }

  private measureEventLoopDelay(): number {
    // 简化实现，生产环境使用 perf_hooks
    const start = performance.now();
    setImmediate(() => {
      const delay = performance.now() - start;
      return delay;
    });
    return 0;
  }
}
```

#### 11.5.2 告警规则配置

| 告警名称 | 触发条件 | 级别 | 通知方式 | 自动处理 |
|----------|----------|------|----------|----------|
| FPS 过低 | 3秒均值 < 45 | Warning | 控制台日志 | 触发 L1 降级 |
| FPS 严重过低 | 3秒均值 < 30 | Critical | 日志 + 桌面通知 | 触发 L3 降级 |
| 内存泄漏疑似 | heapUsed 连续 5 分钟单调递增 | Warning | 日志 | 记录堆快照路径 |
| 内存超限 | RSS > 350MB | Critical | 日志 + 桌面通知 | 强制 GC + 清理缓存 |
| Event Loop 阻塞 | 延迟 > 100ms | Critical | 日志 | 暂停非关键定时器 |
| OBS 编码器过载 | 负载 > 90% 持续 10s | Warning | 日志 | 触发特效降级 |
| 推流断开 | OBS WebSocket 断连 | Critical | 日志 + 桌面通知 | 自动重连（§11.3.3） |
| 礼物监听断开 | 抖音 WS 断连 | Error | 日志 + 桌面通知 | 自动重连 |
| AI 决策超时 | 单次决策 > 5s | Warning | 日志 | 使用兜底随机出牌 |
| TTS 连续失败 | 连续 3 次合成失败 | Error | 日志 | 降级为静默模式 |
| SQLite 写入失败 | 任意写入操作失败 | Error | 日志 | 切换内存缓存 |
| 敏感词命中 | 单场累计 ≥ 3 次 | Warning | 日志 + 合规告警 | 暂停 AI 发言，人工介入 |

#### 11.5.3 告警通知实现

```typescript
type AlertLevel = 'info' | 'warning' | 'error' | 'critical';

interface AlertRule {
  name: string;
  level: AlertLevel;
  condition: () => boolean;
  action: () => void;
  /** 同一告警最小间隔（ms），防止告警风暴 */
  cooldown: number;
}

class AlertManager {
  private rules: AlertRule[] = [];
  private lastFired = new Map<string, number>();

  register(rule: AlertRule): void {
    this.rules.push(rule);
  }

  /** 由 HealthCollector 每次采集后调用 */
  evaluate(): void {
    const now = Date.now();
    for (const rule of this.rules) {
      const last = this.lastFired.get(rule.name) ?? 0;
      if (now - last < rule.cooldown) continue;

      if (rule.condition()) {
        this.lastFired.set(rule.name, now);
        logger.warn(`[Alert:${rule.level}] ${rule.name}`);
        rule.action();

        if (rule.level === 'critical') {
          this.sendDesktopNotification(rule.name);
        }
      }
    }
  }

  private sendDesktopNotification(title: string): void {
    // Electron / node-notifier 桌面通知
    new Notification('AI斗地主直播 - 告警', { body: title });
  }
}
```

---

## 12. 附录

### 12.1 跨文档引用索引

本文档与其他策划文档的引用关系汇总：

| 本文档章节 | 引用目标 | 引用内容 |
|-----------|----------|----------|
| §2.1 前端渲染引擎 | 02-前端界面设计 §2.1 | 6 层 z-index 分层架构 |
| §2.1 前端渲染引擎 | 03-特效与动画设计 §1.2 | PixiJS + GSAP + CSS 技术栈 |
| §3 AI 决策引擎 | 01-斗地主规则 §3 | 牌型枚举与合法出牌判定 |
| §4 TTS 解说模块 | 06-直播内容与赛事策划 §3 | 解说触发规则与文案模板 |
| §4 TTS 解说模块 | 07-合规风控 §4.3 | 敏感词替换规则 |
| §5 OBS 推流模块 | 04-OBS直播技术方案 §2-§4 | RTMP 推流参数与场景切换 |
| §6 礼物互动模块 | 05-礼物互动系统 §2-§11 | 礼物分级、效果映射、防滥用 |
| §6 礼物互动模块 | 07-合规风控 §4.4 | 礼物效果合规边界 |
| §8 模块间通信 | 01-斗地主规则 §5 | 状态机阶段定义 |
| §11.1 性能预算 | 03-特效与动画设计 §16 | 前端性能指标对齐 |
| §11.5 监控告警 | 07-合规风控 §6.3 | 敏感词命中告警阈值 |

### 12.2 npm 依赖清单

#### 12.2.1 生产依赖

| 包名 | 版本 | 用途 | 所属模块 |
|------|------|------|----------|
| pixi.js | ^7.x | WebGL 2D 渲染引擎 | frontend |
| @pixi/particle-emitter | ^5.x | PixiJS 粒子系统 | frontend |
| gsap | ^3.x | 动画时间线编排 | frontend |
| react | ^18.x | UI 框架 | frontend |
| react-dom | ^18.x | React DOM 渲染 | frontend |
| zustand | ^4.x | 状态管理 | shared |
| howler | ^2.x | 音频播放引擎 | frontend |
| lottie-web | ^5.x | Lottie 矢量动画 | frontend |
| edge-tts | ^1.x | 微软 Edge TTS 语音合成 | server |
| better-sqlite3 | ^9.x | SQLite 同步驱动 | server |
| obs-websocket-js | ^5.x | OBS WebSocket 控制 | server |
| ws | ^8.x | WebSocket 客户端（抖音连接） | server |
| eventemitter3 | ^5.x | 高性能事件总线 | shared |
| uuid | ^9.x | 唯一 ID 生成 | shared |
| winston | ^3.x | 结构化日志 | server |
| dayjs | ^1.x | 日期时间处理 | shared |

#### 12.2.2 开发依赖

| 包名 | 版本 | 用途 |
|------|------|------|
| typescript | ^5.x | TypeScript 编译器 |
| vite | ^5.x | 前端构建工具 |
| vitest | ^1.x | 单元测试框架 |
| eslint | ^8.x | 代码规范检查 |
| prettier | ^3.x | 代码格式化 |
| @types/better-sqlite3 | ^7.x | SQLite 类型定义 |
| @types/ws | ^8.x | WebSocket 类型定义 |
| tsx | ^4.x | TypeScript 直接执行（开发环境） |
| concurrently | ^8.x | 多进程并行启动 |

### 12.3 术语表

| 术语 | 英文 | 含义 |
|------|------|------|
| 地主 | Landlord | 斗地主中持有底牌的一方，1v2 |
| 农民 | Farmer | 斗地主中与地主对抗的两人 |
| 叫分 | Bidding | 玩家竞争地主身份的过程（1/2/3分） |
| 炸弹 | Bomb | 四张相同点数的牌，可压制任何非火箭牌型 |
| 火箭/王炸 | Rocket | 大小王组合，最大牌型 |
| 春天 | Spring | 地主出完牌而农民一张未出，或反之 |
| 能量加成 | Score Multiplier | 虚拟战绩倍数（合规用语，替代"翻倍"） |
| 战绩分 | Honor Points | 虚拟积分（合规用语，替代"筹码"） |
| EventBus | - | 模块间事件通信总线 |
| EventPipeline | - | 礼物事件处理管道（去重→冷却→公平→映射） |
| GameStore | - | Zustand 全局游戏状态仓库 |
| HealthCollector | - | 系统健康度指标采集器 |
| 降级 | Degradation | 性能不足时自动降低特效/功能等级 |
| RTMP | Real-Time Messaging Protocol | OBS 推流协议 |
| TTS | Text-to-Speech | 文本转语音 |
| SSML | Speech Synthesis Markup Language | 语音合成标记语言 |

### 12.4 状态机枚举速查

#### 游戏阶段（GamePhase）

```typescript
enum GamePhase {
  WAITING    = 'WAITING',    // 等待开局
  DEALING    = 'DEALING',    // 发牌中
  BIDDING    = 'BIDDING',    // 叫地主/抢地主
  PLAYING    = 'PLAYING',    // 出牌阶段
  SETTLEMENT = 'SETTLEMENT', // 结算阶段
}
```

> **规范说明**：以上为全项目统一的状态机命名，所有文档（01、02、05、08）均以此为准。

#### 礼物等级（GiftTier）

```typescript
type GiftTier = 'small' | 'medium' | 'large' | 'super';
// small:  1-9 抖币    → 氛围类，不影响牌局
// medium: 10-99 抖币  → 信息干预类
// large:  100-999 抖币 → 中度干预类
// super:  1000+ 抖币  → 强力干预类
```

#### 性能降级等级（DegradationLevel）

```typescript
type DegradationLevel = 0 | 1 | 2 | 3;
// 0: 正常 — 全特效
// 1: 轻度 — 粒子数减半
// 2: 中度 — 关闭粒子，仅基础动画
// 3: 重度 — 关闭所有特效，仅出牌位移
```

### 12.5 EventBus 事件速查表

| 事件名 | 发布者 | 订阅者 | 载荷概要 |
|--------|--------|--------|----------|
| `game:phase_changed` | GameEngine | Frontend, TTS, OBS | `{ from, to, roundId }` |
| `game:card_played` | GameEngine | Frontend, TTS | `{ playerId, cards, cardType }` |
| `game:bid` | GameEngine | Frontend, TTS | `{ playerId, score }` |
| `game:round_end` | GameEngine | Frontend, TTS, Stats | `{ winner, scores, multiplier }` |
| `game:bomb` | GameEngine | Frontend, TTS | `{ playerId, cards }` |
| `game:rocket` | GameEngine | Frontend, TTS | `{ playerId }` |
| `game:spring` | GameEngine | Frontend, TTS | `{ type, winnerId }` |
| `gift:received` | GiftListener | EventPipeline | `{ GiftEvent }` |
| `gift:effect_triggered` | EventPipeline | GameEngine, Frontend | `{ effectType, target, data }` |
| `gift:effect_rejected` | EventPipeline | Logger | `{ reason, gift }` |
| `tts:speak` | TTS Module | Frontend | `{ text, voice, priority }` |
| `tts:finished` | TTS Module | GameEngine | `{ id }` |
| `obs:scene_switch` | OBS Module | Logger | `{ sceneName }` |
| `obs:stream_status` | OBS Module | AlertManager | `{ streaming, fps }` |
| `system:performance_level` | PerformanceDegrader | Frontend, EffectManager | `{ level: 0-3 }` |
| `alert:connection_failed` | ReconnectManager | AlertManager | `{ module, attempts }` |
| `compliance:sensitive_hit` | SensitiveFilter | AlertManager, Logger | `{ word, context }` |

### 12.6 目录结构速查

```
zhibo_doudizhu/
├── packages/
│   ├── engine/          # 斗地主游戏引擎（规则、状态机、AI决策）
│   ├── ai/              # AI 策略模块（规则型 + 概率型）
│   ├── frontend/        # React + PixiJS 前端渲染
│   ├── server/          # Node.js 主控服务（TTS、OBS、礼物监听）
│   └── shared/          # 共享类型、EventBus、常量
├── data/
│   ├── db/              # SQLite 数据库文件
│   ├── logs/            # JSONL 日志（90天保留）
│   └── tts-cache/       # TTS 音频缓存
├── assets/
│   ├── sprites/         # PixiJS SpriteSheet
│   ├── audio/           # 音效 + BGM
│   ├── lottie/          # Lottie 动画 JSON
│   └── fonts/           # 字体文件
├── scripts/             # 启动/部署脚本
├── docs/                # 策划文档（00-09）
├── pnpm-workspace.yaml
├── package.json
└── tsconfig.base.json
```

---

*本文档为 AI 斗地主直播项目的技术架构设计完整方案（v1.0），共 12 章，涵盖系统架构、各模块详细设计、通信协议、部署方案、技术选型、性能与可靠性设计。与其他策划文档（01-07、09）配合使用，共同指导项目开发实施。*